---
title: "Discovering basic {{< fa brands r-project >}} objects"
#echo: false
number-sections: true
code-annotations: hover
---

::: {.badge}
<a href="https://datalab.sspcloud.fr/launcher/ide/rstudio?autoLaunch=false&networking.user.enabled=true&onyxia.friendlyName=%C2%ABrstudio-cours-ENS%C2%BB" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/Test%20via%20SSP%20cloud%20-%20SSPCloud?logo=R&labelColor=black&color=%231965b8" alt="Onyxia"></a><br>
:::

<details>
<summary>
Unfold the _slides_ below or [click here](/slides/introduction.qmd)
to display the slides in full screen.
</summary>
```{.yaml code-preview="/slides/introduction.qmd"}
```

</details>

In this first tutorial,
we will gently begin
our journey of discovering 
{{< fa brands r-project >}}. 

This will be done through the following steps:

1. Familiarization with `RStudio`, the software that will allow us to use the {{< fa brands r-project >}} language;
2. Discovery of basic {{< fa brands r-project >}} objects: vectors of **numbers**, **character strings** and logical conditions, **lists** and _**dataframes**_;
3. Discovery of **assignment** of objects to **variables** to perform operations with them.

:::{.callout-note collapse="true"}
## Note on annotations
Some code examples include annotations on the side,
hover over them to display them, as shown below
```{r}
#| echo: true
#| output: false
"an explanatory annotation accompanies me on the right" #<1>
```
1. I appear when you hover over me üê≠!

:::

# Familiarization with `RStudio`

Usually, to work with {{< fa brands r-project >}}, we 
use the `RStudio`[^rstudio] software which offers an environment that's a bit less
rudimentary than the default graphical interface provided when installing
{{< fa brands r-project >}}.

[^rstudio]: To install `RStudio` yourself, instructions are [here](https://posit.co/download/rstudio-desktop/). However, for this course, you won't need to do the installation, we'll
use a preconfigured infrastructure. This way, we'll have 
access to the same environment.

To launch an `RStudio` service on preconfigured servers, we'll
use an infrastructure called [`SSPCloud`](https://datalab.sspcloud.fr/)
which is developed by Insee's innovation team for
teaching or _data science_ projects.

![](https://git.lab.sspcloud.fr/diit/presentation/energy-data-hack-2022/20220523-day_1-onyxia_onboarding/-/raw/main/slideshow/macbook_onyxia.png){width=50% fig-align="center"}

<br>
After creating an account on [datalab.sspcloud.fr/](https://datalab.sspcloud.fr/),
click on this button:

::: {.badge}
<a href="https://datalab.sspcloud.fr/launcher/ide/rstudio?version=1.15.13&networking.user.enabled=true&onyxia.friendlyName=%C2%ABrstudio-cours-ENS%C2%BB¬ª&networking.user.enabled=true&onyxia.friendlyName=¬´rstudio-cours-ENS¬ª" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/Test%20via%20SSP%20cloud%20-%20SSPCloud?logo=R&labelColor=black&color=%231965b8" alt="Onyxia"></a><br>
:::

After a few moments of launching the service on Insee's servers, 
you'll be able to access your ready-to-use `RStudio` (live
demonstration or [memory aid](/slides/introduction.html#/prise-en-main-du-ssp-cloud))

:::{.callout-tip collapsable="true"}
## Exercise 1: getting familiar with `RStudio`

This first exercise aims, after observing the structure of `RStudio`'s windows,
to get to grips with the interface:

1. Observe the structure of your working folder at the bottom right of `RStudio`;
2. Create a script from the menu `File/New File/R script` and save it under the name `script1.R`;
3. Observe the update of your folder at the bottom right;
4. Do a search in RStudio's Help section for the `list.files` function;
5. Write in `script1.R` the code that lists the files in your working folder;
6. Use the `RStudio` shortcut <kbd>CTRL</kbd> + <kbd>ENTER</kbd> to execute this code in the console.

::: 

# One-dimensional objects

We'll start with one-dimensional objects, that is,
lists of values of the same type. For example, `["ENS Ulm", "ENS Lyon", "ENS Paris-Saclay"]`
or `[4 8 15 16 23 42]`. 

These lists of one-dimensional values can be represented
by __vectors__. The four most practical types
in {{< fa brands r-project >}} are:

- [Numeric vectors](#numeric);
- [Character strings](#characters);
- [Logical vectors](#logical);
- [Factors](#factors).

We'll then move to more complex data structures
which are actually those we manipulate more 
commonly: [lists](#lists) and [_dataframes_](#dataframes). 

## Numeric vectors (_numeric_) {#numeric}

### Two types of numeric vectors

{{< fa brands r-project >}} offers different types of numeric objects. For data analysis, we'll mainly
focus on two types:

- integers (type `int` for *integer*)
- real numbers (type `double` for floating-point numbers)

In practice, the former are a special case of the latter. Unlike other languages,
{{< fa brands r-project >}} doesn't attempt to automatically constrain whole numbers to be
integers (_integers_). This is convenient but on large data volumes it can
be problematic because _doubles_ are heavier than _ints_. 

Generally, we use the `class` function to display the type of a {{< fa brands r-project >}} object and
if we want to be more precise we can use `typeof`:
```{r}
#| echo: true
#| output: false
class(3)
typeof(3)
class(3.14)
typeof(3.14)
```

The `as.numeric` and `as.integer` functions can be used to convert from one type to another:
```{r}
#| echo: true
# Conversion to int
as.integer(3.79)
```

::: {.callout-warning}
Be careful with *double* $\to$ *int* conversion, which truncates the decimal part.
```{r}
#| echo: true
# double -> int -> double
as.numeric(
    as.integer(3.79)
)
```
:::

_Floats_ can also be written in scientific notation:
```{r}
#| echo: true
2e3
class(2e3)
```

### Basic arithmetic operations

![](img/verybadtrip.gif){fig-align="center"}

Like any computer language, {{< fa brands r-project >}} is first and foremost
a calculator. We're saved, we can therefore do additions:
```{r}
#| echo: true
# Addition
8 + 9
```

::: {.callout-note}
{{< fa brands r-project >}} is well designed, it adapts variable types to make them consistent when they
can be:
```{r}
#| echo: true
# Addition
8.1 + as.integer(9)
```

:::

We of course have access to other standard operations:
```{r}
#| echo: true
# Subtraction
5 - 2
# Multiplication
2 * 6
# Division
9 / 4
```

We still need to be careful with division by 0
```{r}
#| echo: true
# Division by 0
3 / 0
-5 / 0
```

::: {.callout-warning}
Some languages, like `Python`, don't allow division by 0, they return 
an error rather than `Inf`. This is a bit tricky in `R` because we can
have divisions by 0 without realizing it...
:::

Like any calculator, we can apply other types of operations
```{r}
#| echo: true
#| label: euclidean-division
# Euclidean division: quotient
9 %/% 4
# Euclidean division: remainder
9 %% 4
```

```{r}
#| echo: true
# Power
2 ^ 5
# Square root
sqrt(5)
# Log
log(2)
# Exponential
exp(2)
```

The order of operations follows the usual convention:
```{r}
#| echo: true
2 + 5 * (10 - 4)
```

### Vectorization

If we could only use {{< fa brands r-project >}}
in basic calculator mode,
it wouldn't be a very interesting language for data
analysis. The main advantage of {{< fa brands r-project >}}
is that we can
manipulate vectors, i.e., sequences of numbers.
We'll consider vectors to be sequences of numbers
ordered in a single column:

$$
\begin{bmatrix} x_1 \\ x_2 \\ \vdots \\ x_n \end{bmatrix}
$$

and we'll apply operations to each row of these vectors. 
We speak of __vectorization__ of operations to designate an operation
that will automatically apply to each element of our
vector.

For example, multiplication is vectorial by default:
```{r}
#| echo: true
5*c(1,20,2)
```

Same with addition, as long as we have vectors of consistent size:
```{r}
#| echo: true
c(1,20,2) + c(21,2,20)
c(1,20,2) - 3
```

::: {.callout-warning}
If the size of vectors isn't consistent, {{< fa brands r-project >}}
recycles the smaller vector until reaching the right size
```{r}
#| echo: true
c(1,20,2) - c(1,20)
```

:::

## Character strings (_characters_) {#characters}

Character strings (or *strings*) are used to store textual information.
More precisely, they can store any [Unicode](https://en.wikipedia.org/wiki/Unicode) character, which includes letters from different languages, but also punctuation, numbers, smileys, etc.

### Creating a _string_

To create a character string (_string_), we
can use either quotes or
apostrophes interchangeably. 
```{r}
#| echo: true
'word' # <1>
"this works too" # <2>
```
1. First method: `'`
2. Second method (preferable): `"`

:::{.callout-warning}
Be careful about mixing the two!
```{r}
#| echo: true
#| error: true
print('the apostrophe, what a catastrophe')
```

The second apostrophe is understood as the end of the _string_,
and {{< fa brands r-project >}} doesn't know how to interpret the rest of the sequence.

We must therefore vary as needed:
```{r}
#| echo: true
"the apostrophe, no problem" # <1>
```
1. This time, the apostrophe `'` is properly nested within the quotes that
delimit our _string_.

This also works in reverse: quotation marks are properly
interpreted when they're between apostrophes. 
```{r}
#| echo: true
'quotation marks, "no problem"'
```

As the output above shows, it's
possible to properly define special
characters of this sort by escaping them with backslashes `\`:
```{r}
#| echo: true
"quotation marks, \"no problem\"" # <1>
'the apostrophe, no problem' # <1>
```
1. `\` allows {{< fa brands r-project >}} to understand that the apostrophe
or quotation mark is part of the character string and not its delimiter.

:::

### Some useful functions

{{< fa brands r-project >}} provides by default a certain number
of useful functions to 
extract or transform text vectors. We'll discover
more practical and general ones when we focus on
textual data and the [`stringr`](https://stringr.tidyverse.org/) package.

The `nchar` function counts the number of characters in a *string*, all characters included (letters, numbers, spaces, punctuation...).
```{r}
#| echo: true
nchar("I have 19 characters")
```

It shouldn't be confused with the `length` function. This one
gives us the vector length. For example, 
```{r}
#| echo: true
length("I have 19 characters")
```

is of size 1 since we have a single element in our vector.
If we take a larger dimension vector:
```{r}
#| echo: true
length(c("I have 19 characters", "not me"))
```

We correctly get the number of elements in our vector from `length`.

`nchar` is a vectorial operation, so we can count the length
of each row in our dataset:
```{r}
#| echo: true
nchar(c("I have 19 characters", "not me"))
```

One of the interests of base text data processing functions
is the possibility of automatically reformatting our character
strings. For example, the 
simplest operation is to change the capitalization of our text:
```{r}
#| echo: true
toupper(c("sequence 850", "Sequence 850")) # <1>
tolower(c("SEQuEnce 850", "SEQUENCE 850")) # <2>
```
1. Put all text in uppercase.
2. Put in lowercase.

But we can also clean text strings with some base functions:
```{r}
#| echo: true
strsplit(c("a sequence    to separate", "anothertoseparate"), split = " ")
```

At this stage, the output obtained, with `[[]]`
may seem strange to you because we haven't
yet discovered the `list` type.

Since this type of data isn't necessarily practical
for statistical analysis, for which we prefer formats
like vectors, it will be much more practical to use
the `stringr` _package_ to do a _split_.

We can certainly split our _string_ on something other than spaces!
```{r}
#| echo: true
strsplit(c("a sequence    to separate", "anothertoseparate"), split = "to")
```

We can concatenate character strings together, it's very practical. 
Unfortunately the `+` doesn't work in `R` for character 
strings (unlike `Python`). To do this we 
use `paste` or `paste0` (a less general version but which is
designed for simple concatenations):
```{r}
#| echo: true
#| label: paste
paste0(
    "The first time Aur√©lien saw B√©r√©nice,",
    " ",
    "he found her frankly ugly. She displeased him, in short.",
    " ",
    "He didn't like how she was dressed."
) # <1>

paste(
    "The first time Aur√©lien saw B√©r√©nice,",
    "he found her frankly ugly. She displeased him, in short.",
    "He didn't like how she was dressed.",
    sep = " "
) # <2>
```

1. With `paste0`, we concatenate by joining _strings_, without spaces.
2. With `paste`, we can choose how to join _strings_, here
by adding spaces.

We can use strings as _templates_. This is particularly
practical for automatically creating text from values 
from our data. For this we use `sprintf`:
```{r}
#| echo: true
sprintf("The first time %s saw %s", "Aur√©lien", "B√©r√©nice")
sprintf("%s and %s make %s", 2, 2, 2+2)
```

`%s` is used to define where the desired text will be pasted. 

## Logical vectors (_logicals_) {#logicals}

In {{< fa brands r-project >}},
logical vectors are used to store boolean values,
i.e., true (`TRUE`) or false (`FALSE`) values.

Logical vectors are commonly used to perform logic operations, data filters and conditional selections. 
We'll come back to this later, we'll use them frequently but indirectly.
```{r}
#| echo: true
5 > 3  # <1>
2 == 2 # <2> 
0 == (2 - 2) # <3>
1 < 0 # <4>
```
1. `TRUE`, because 5 is greater than 3.
2. `TRUE`, because 2 equals 2.
3. `TRUE`, the operation chain is respected.
4. `FALSE`, because 1 is not less than 0.

We can generalize comparisons to get vectors:
```{r}
#| echo: true
c(2, 4, 6, 8, 10, 1, 3) %% 2 == 0
```

We get `TRUE` for even numbers, `FALSE` for odd ones.

Using logical vectors will allow us, on a daily basis,
to select data. For example if we have age data, we
may only want to keep adults' names. This can be done
following this model:
```{r}
#| echo: true
c('Pierre', 'Paul', 'Fran√ßois', 'and others')[
    c(25, 3, 61, 17) >= 18
]
```

However we'll see in the next chapters
how to integrate this principle into
a more general sequence of operations thanks to the [`dplyr`](https://dplyr.tidyverse.org/reference/filter.html) package.

## Factors (_factors_) {#factors}

Factors (_factors_) are used to represent
__categorical variables__,
i.e., variables that take a finite and predetermined number of levels or categories.

To convert a numeric or text vector to a factor, we use
the `factor` function:
```{r}
#| echo: true
factor(
    c("capital","prefecture","sub-prefecture","prefecture")
)
factor(c(1,10,3))
```

The levels of a factor are the different categories
or possible values that the variable can take. 
We can list them with the `levels` function
```{r}
levels(
    factor(
        c("capital","prefecture","sub-prefecture","prefecture")
    )
)
```

We can also order these levels if it makes sense when defining
the factor. This however involves knowing, _a priori_ our different 
levels and informing {{< fa brands r-project >}} in order:
```{r}
factor(
    c("capital","prefecture","sub-prefecture","prefecture"),
    levels = c("capital","prefecture","sub-prefecture"),
    ordered = TRUE
)
```

# Creating variables

Until now, we've had to define our object each time before being able to apply a transformation to it. How can we reuse an object and apply multiple transformations to it? Or perform operations from different objects?

For this, we'll __assign__ objects to variables.
This then allows performing operations from these variables.

In {{< fa brands r-project >}},
assignment is done following the format:
```r
variable_name <- object
```

The direction of the arrow matters and it's
conventional to put on the left the
variable name (and therefore
to use `variable_name <- object` rather than `object -> variable_name`).

::: {.callout-note}

Assignment in the form `<-` is a specificity
of {{< fa brands r-project >}} compared
to many languages. In most computer languages,
like `Python` for example,
assignment is done with `=`:
```r
variable_name = object
```

This is also possible in {{< fa brands r-project >}} but it's
more conventional to use `<-`.

:::

Here's for example how to create a vector `x`:
```{r}
#| echo: true
x <- 5
x
```

This can then be reused later in the code: 
```{r}
#| echo: true
class(x)
```

Variables can be any type of {{< fa brands r-project >}} object
and we can create a variable from another:
```{r}
#| echo: true
x <- c(5, 10)
y <- x + 2*x
y
```

::: {.callout-warning}
Unlike other programming languages, {{< fa brands r-project >}}
is said to be *dynamically* typed:
it's possible to reassign a variable to an object of different type. 
This facilitates reading and development, but can sometimes generate problems difficult to debug...

We must therefore always pay close attention that the variable type is indeed what we imagine we're manipulating.
```{r}
#| echo: true
x <- 3
x <- "blabla"
class(x) #<1>
```
1. `x` is no longer a _numeric_ but a _character_. Watch out for upcoming operations on `x`!
:::

There are naturally certain constraints on operations depending on object types.
```{r}
#| echo: true
#| error: true
x <- "test"
y <- 3
x + y # <1>
```
1. Addition `+` doesn't exist for _strings_ as we saw previously

It's however possible to harmonize types beforehand:
```{r}
#| echo: true
x <- "5"
y <- 3
z <- as.numeric(x)
y + z
```

# Indexing

In {{< fa brands r-project >}},
position indices in vectors allow accessing specific elements using their position in the vector. 
Indices start at `1`, which means the first element has an index of 1, the second has an index of 2, and so on[^noteindice].

[^noteindice]: 
  This remark may seem trivial but, in computer science, it isn't. 
  Many languages (`Python`, `C`) have indexing that starts at 0, as
  is the convention in algebra.
  This means the first element has an index
  0, the second index 1 and the last an index $n-1$.
```{r}
#| echo: true
x <- 2*seq(1,10)
```

To access a specific element of the vector using its position index, we use the notation `[ ]`. 
For example, to get the second element of `x`, you can do this:
```{r}
#| echo: true
# Access the second element of the vector
second_position <- x[2]
second_position
```

Now, the variable `second_position` contains the value 4.

::: {.callout-note}
We can moreover update the vector `x`, this won't change
the value of the variable `second_position`:
```{r}
#| echo: true
x <- seq(5,9)
print(second_position)
second_position == x[2]
```

In {{< fa brands r-project >}},
a variable's value is only changed if there's,
in one way or another, reassignment. 
:::

We can also use a sequence of values to retrieve
a subset of our vector (this operation is called a _slice_)
```{r}
#| echo: true
x <- seq(5,15)
x[1:5]
x[c(2,3,8)]
```

It's also possible to make negative selections, i.e.,
all values except certain ones. For this, we use negative indices
```{r}
#| echo: true
x[-3] # <1>
x[c(-3, -1)] # <2>
```
1. We select all data except the first element
2. We select all data except the first and third elements (order doesn't matter)

However, it's not good practice to use 
numbers directly. Indeed, imagine you transform
your vector in a long chain of operations: you no longer
necessarily know which positions store which values (and with 
real datasets you don't even know exactly which
rows of your dataset store which values). 

This is why we prefer selections from logical
conditions. We saw this previously in this form:
```{r}
#| echo: true
c('Pierre', 'Paul', 'Fran√ßois', 'and others')[
    c(25, 3, 61, 17) >= 18
]
```

Now that we know intermediate variable assignment, 
the syntax simplifies, which makes the code more readable. 
```{r}
#| echo: true
first_name <- c('Pierre', 'Paul', 'Fran√ßois', 'and others')
age <- c(25, 3, 61, 17)
first_name[age >= 18]
```

Another example to illustrate with text data:
```{r}
#| echo: true
cities <- c("Paris", "Toulouse", "Narbonne", "Foix")
status <- c("capital","prefecture","sub-prefecture","prefecture")
cities[status == "prefecture"]
```

We'll discover in the next chapter a generalization of this
approach with data __filters__. 

# Missing values

Real datasets aren't always complete. They're
even rarely so. For example, 
in long GDP series, retrospective values may
be missing for countries that didn't exist before a certain date. 

Missing values, often represented
by `NA` (Not Available) in {{< fa brands r-project >}},
are an essential aspect of data management and
one of {{< fa brands r-project >}}'s
strengths is offering consistent management of these. For example, if we want to
calculate the world average of GDP for a past year: should we exclude or not
countries for which we have no information that year or return an error?
Appropriate management of missing values is therefore
crucial when analyzing data and creating statistical models.

The `is.na()` function checks if a value
is missing in a vector:
```{r}
#| echo: true
data <- c(10, NA, 30, NA, 50) # <1>

is.na(data) # <2>
```
1. Create a vector with missing values.
2. Returns `TRUE` for missing values, `FALSE` otherwise.

Appropriate management of missing values is crucial 
to avoid biases in statistical analyses
and to obtain reliable results
because missing values are rarely random: there's often a reason why a value is missing
and the assumption of [_missing at random_](https://stefvanbuuren.name/fimd/sec-MCAR.html) is often false. 

::: {.callout-note collapse="true"}
## Note on missing value management

There are several approaches to handle missing values depending on an analysis's objective. This exceeds the scope of this course but
here are, broadly speaking, the three most common strategies:

- __Deletion of missing values__: delete rows containing missing values using the `na.omit()` or `complete.cases()` function. This is for example what linear regression does by default in `R`. However, this approach can lead to information loss or bias introduction, so it shouldn't be done lightly;
- __Imputation of missing values__: By making assumptions about the underlying distribution of missing values, these values can be estimated. The simplest method is to impute to the mean or median but there are less crude methods like regression or methods based on nearest neighbors. However this imputation shouldn't be taken lightly as it changes the distribution of the observed variable, which can have an
impact on subsequent analyses, and it's very dependent on modeling choice;
- __Treat missing values as a separate group__: In descriptive statistics, it's possible to perform analyses by putting a group where missing values are frequent separately.
:::

# Exercises on one-dimensional objects

First series of exercises on one-dimensional objects
allowing to deepen the concepts seen previously.

<details>
<summary>
Your state after this series of exercises?
</summary>

![](img/exhausted.png){width=70% fig-align="center"}

</details>

:::{.callout-tip}
## Exercise 2

Display the type of `x` when: 
```{r}
#| echo: true
x <- 3
x <- "test"
x <- 3.5
```
```{r}
#| output: false
#| code-fold: true
#| code-summary: "Solution"
typeof(3)
typeof("test")
typeof(3.5)
```

:::

:::{.callout-tip}
## Exercise 3

Calculate the sum of lengths of each of the following character strings: 

- _"a first string"_
- _"and a second"_
- _"never two without three"_
```{r}
#| output: false
#| code-fold: true
#| code-summary: "Solution"
x1 <- "a first string"
x2 <- "and a second"
x3 <- "never two without three"
nchar(paste(x1, x2, x3, sep = ""))
```
:::

:::{.callout-tip}
## Exercise 4

Municipality codes are standardized identifiers,
specific to each municipality (which differentiates them from
postal codes). They come from
the [official code](https://www.insee.fr/fr/information/6800675) that
we'll discover later?

[^cognote]: The rest of the course will be an opportunity to amply use this dataset. 

<details>
<summary>
Help if you don't see where the problem is
</summary>
Test on the first departments, for example `02350`.
</details>
:::

:::{.callout-tip}
## Exercise 5

Here's a list of municipality codes from the [Official Geographic Code (COG)]((https://www.insee.fr/fr/information/6800675))
```{r}
#| echo: true
municipality_list <- c(
  '01363', '02644', '03137', '11311', '12269', '13018', '14458', '15008',
  '23103', '2A119', '2B352', '34005', '2B015', '2A015',
  '38188', '39574', '40223', '41223', '42064',
  '63117', '64218', '65209', '66036', '67515', '68266', 
  '77440', '78372', '79339', '80810', '81295', '82067',
  '93039', '94054', '95061', '97119', '97219', '97356', '97421', '97611'
)
```

1. Extract the department (first two characters) for each municipality;
2. Count the number of unique departments in our data;
```{r}
#| code-fold: true
#| code-summary: "Solution"
#| output: false

# Question 1
dep <- substr(municipality_list, start = 1, stop = 2)
# Question 2
length(
  unique(dep)
)
```

:::

::: {.callout-tip}
## Exercise 6

Remove superfluous spaces at the beginning and end of the following string:
```{r}
#| echo: true
#| output: false
a <- "    A very badly formatted string.         "
```
```{r}
#| code-fold: true
#| code-summary: "Solution"
trimws(a)
```

<details>
<summary>Help, if you're stuck</summary>
Type `?trimws()` in the console to display help for the `trimws()` function 
</details>

:::

Since base text data manipulation functions are sometimes
a bit difficult to use with {{< fa brands r-project >}}, we can go much further 
when we discover the `stringr` package.

# More complex structures

## Matrices

__Matrices__ can be seen as the two-dimensional
extension of vectors. Instead
of having data on a single dimension, we stack columns side by side.

$$
X = \begin{bmatrix}
x_{11} & x_{12} \\
x_{21} & x_{22} \\
\end{bmatrix}
$$

However, matrices have a fundamental limitation: we can only store in
a matrix elements of the same type. In other words, we'll exclusively
have numeric matrices, character matrices or logical matrices. 
It's impossible to build a matrix where some variables are numeric (for example survey respondents' age) and others are character type (for example their sector of activity). 

Matrices therefore don't constitute an object type likely to store the statistical information usually used in social surveys.
Mixing types isn't practical, which is why
data analysis practitioners use them little[^matrices].

[^matrices]: The matrix object will mainly be used by 
mathematical statistics researchers or
algorithm specialists who will manipulate low-level numeric objects. 

We therefore propose an exercise on matrices but we'll quickly move
to more flexible types, more useful for data analysis where 
variables are of diverse types. 

:::{.callout-tip}
## Exercise 7

Given a matrix:
```{r}
#| echo: true
X <- matrix(letters[1:20], nrow = 4, ncol = 5)
```
```{r}
#| code-fold: true
#| code-summary: "Solution"
#| output: false
X[1,1] # <1>
X[1,]  # <2>
X[,1]  # <3>
X[2:3,c(1,3)] #<4>
```
1. Select the leftmost element of our matrix (first row, first column)
2. Select the entire first row
3. Select the entire first column
4. Select elements at the intersection of:
    + 2nd and 3rd rows
    + 1st and 3rd columns

<details>
<summary>
Hint if you're stuck
</summary>
With a vector, we accessed element positions with `X[*]`.
With matrices the principle is the same but we add a dimension `X[*,*]`
</details>
:::

## Lists

__Lists__ constitute a much richer object type that precisely allows bringing together very different types of objects: a list can contain all object types (numeric vectors, characters, logicals, matrices, etc.), including other lists.

This very great flexibility makes the list the object of choice for storing complex and structured information, particularly results of complex statistical procedures (regression, classification, etc.).
For more structured data, as datasets are, we'll see next that we'll
use a special type of list: the **_dataframe_**. 

![Proposed illustration of the list principle with `R` by [Dall-E-2](https://openai.com/dall-e-2)](img/boites.png){width=50% fig-align="center"}

:::{.callout-tip}
## Exercise 8

Here's a list illustrating the principle of storing
heterogeneous data in the same object:
```{r}
#| echo: true
my_list <- list(
    1,
    "text",
    matrix(letters[1:20], nrow = 4, ncol = 5),
    c(2, 3, 4)
)
```

1. Display the list and observe the difference with the display
of previous objects
2. Use the `[[]]` notation to access the 2nd element of our
list to the 2nd number within the last element of our matrix
3. We can use names for our list's elements (it's
moreover a good practice). Create an element named `municipalities`
in your list storing the following data `c('01363', '02644', '03137', '11311')`
4. Create a `departments` element by extracting the first two digits
of your `municipalities` element
```{r}
#| code-fold: true
#| code-summary: "Solution"
#| output: false

#Question 1: display the list
my_list
# Question 2: Access the second element of the list
my_list[[2]]
my_list[[4]][2]
# Question 3: update the list with a named element and access it
my_list[['municipalities']] <- c(
  '01363', '02644', '03137', '11311'
  )
my_list[['municipalities']]  
# Question 4: perform an operation 
my_list[['departments']] <- substr(my_list[['municipalities']] , start = 1, stop = 2)
```

:::

When using lists, we can perform
operations on each element of our list.
This is called looping over our list.

:::{.callout-tip}
## Exercise 9

In this exercise, we'll discover how to apply the same function
to our list's elements using `lapply`.

1. Before that, how many elements does the first level of our list have? 
2. How many elements does each level of our list have?
3. Create a numeric vector that equals 1 if `typeof` of the element is "double" and 0 otherwise 
```{r}
#| code-fold: true
#| code-summary: "Solution"
#| output: false

# Question 1
list_length <- length(my_list)
# Question 2
lapply(my_list, length)
as.numeric(
    lapply(my_list, function(l) typeof(l) == "double")
)
```

<details>
<summary>If `?lapply` doesn't help</summary>
Example of using `lapply` to sum in each element of our
list
```{r}
#| echo: true
my_number_list <- list(c(1,2), seq(1,10))
lapply(my_number_list, sum)
```

</details>

:::

## _Dataframes_

This is the central object of data analysis with {{< fa brands r-project >}}. 
These objects indeed allow representing in table form (i.e., a two-dimensional object) data of both quantitative nature (numeric variables) and qualitative (character or factor type variables).

![Illustration of the _dataframe_ principle (borrowed from H. Wickham)](https://d33wubrfki0l68.cloudfront.net/6f1ddb544fc5c69a2478e444ab8112fb0eea23f8/91adc/images/tidy-1.png)

Here's for example a `dataframe`:
```{r}
#| echo: true
# Creating the data.frame df
df <- data.frame(
  var1 = 1:10,
  var2 = letters[1:10],
  var3 = rep(c(TRUE, FALSE), times = 5)
)
```

Its internal structure can be verified with the `str` function:
```{r}
#| echo: true
str(df)
```

When working with `R`, one of the functions we use most is `head`. 
It displays the first $n$ rows of our dataset:
```{r}
head(df)
```

::: {.callout-warning}
It's also possible to use `RStudio`'s _viewer_ to display
datasets.

Be careful however, this _viewer_ can encounter
performance problems and crash your `R` session when the dataset
starts to be of considerable size. 

I recommend rather
using `head` or selecting rows randomly with
`sample`:
```{r}
#| echo: true
df[sample(nrow(df), 3), ]
```

:::

From a structural point of view, a `data.frame` is actually a list whose all elements have the same length: this is what allows representing it in the form of a two-dimensional table.
```{r}
#| echo: true
is.list(df)
lapply(df, length)
```

Therefore, `data.frame`s borrow their characteristics sometimes from lists,
sometimes from matrices as the following exercise shows:

::: {.callout-tip}
## Exercise 10

- Check the dimension of dataframe `df`
- Count the number of rows and columns of `df`
- Check the length (_length_) of `df`. Is this the behavior of a
matrix or a list? 
- Extract the element at the 2nd row, 3rd column of `df`. Is this the indexing behavior of a
matrix or a list?
- Retrieve the 3rd row of variables `var1` and `var2`. 
```{r}
#| code-fold: true
#| code-summary: "Solution"
#| output: false

dim(df)
nrow(df)
ncol(df)
length(df) #like a list
df[3, c("var1","var2")]
```

:::

The interest of using a `data.frame` is that we can easily update
our data during statistical analysis. The most classic operations,
which we'll come back to in the next chapter, are 

- Create a new column from pre-existing columns;
- Select a subsample of data corresponding to certain
observed values. 

There are several ways to refer to an already existing column
of a dataframe. The simplest is to use the structure `dataframe$column`. 
This will give us a vector and we fall back on this format we already know:
```{r}
#| echo: true
class(df$var1)
```

::: {.callout-tip}
## Exercise 11

- Create a `var4` column in our dataset equal to the square of `var1`
- Create a `var5` column in our dataset concatenating the first two
variables generalizing the schema `1=a`. 
- Create a `df_small1` dataframe for rows where the logical condition `var3` is verified
- Create a `df_small2` dataframe for rows where `var1` is even (see above the example on Euclidean division for the model)
:::

The next chapter will allow us to go much further thanks
to the `tidyverse` ecosystem and particularly its flagship _package_ `dplyr`.
Without this set of _packages_ greatly facilitating statistical analysis,
{{< fa brands r-project >}} wouldn't have become one of the two flagship
languages of statistics.
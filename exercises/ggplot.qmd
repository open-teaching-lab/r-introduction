---
title: "Data visualisation with {{< fa brands r-project >}} and `ggplot2`"
echo: true
number-sections: true
---

::: {.badge}
<a href="https://datalab.sspcloud.fr/launcher/ide/rstudio?autoLaunch=false&networking.user.enabled=true&onyxia.friendlyName=%C2%ABrstudio-cours-ENS%C2%BB" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/Tester%20via%20SSP%20cloud%20-%20SSPCloud?logo=R&labelColor=black&color=%231965b8" alt="Onyxia"></a><br>
:::

<details>
<summary>
Check out the _slides_ below or [click here](/slides/ggplot.qmd)
to view the slides in full screen.
</summary>


``` {.yaml code-preview="/slides/ggplot.qmd"}
```

</details>


In this practical session,
We will learn how to create synthetic graphical representations with {{< fa brands r-project >}}, which is very well equipped for this task thanks to the `ggplot2` library. This library implements a [grammar of graphics](https://fr.wikibooks.org/wiki/Programmer_en_R/Comprendre_la_grammaire_des_graphiques) that is flexible, consistent, and easy to use.


::: {.callout-note}

Some code examples have annotations on the side; hover your mouse over them to display the notes, like below:


```{r}
#| echo: true
#| output: false
"An explanatory note accompanies me on the right" #<1>
```
1. I appear when you hover your mouse over me üê≠ !

:::

In this course, the practice of visualization will involve replicating charts found on
the Paris *Open Data* page [here](https://opendata.paris.fr/explore/dataset/comptage-velo-donnees-compteurs/dataviz/?disjunctive.id_compteur&disjunctive.nom_compteur&disjunctive.id&disjunctive.name).

This practical session aims to introduce:

* Mainly the [`ggplot2`](https://ggplot2.tidyverse.org/) package for creating static plots;
* The [`plotly`](https://plotly.com/r/) package for interactive HTML plots. We will deepen our knowledge of HTML plots in a later chapter using [`Observable`](https://observablehq.com/).

In this chapter, we will use the following libraries:

```{r}
#| echo: true
#| output: false
library(scales)
library(readr)
library(dplyr)
library(forcats)
library(lubridate)
library(ggplot2)
library(plotly)
```


Then, we will see how to easily create maps in equivalent formats.

::: {.callout-note}
Being able to create interesting data visualizations is an essential skill for any
_data scientist_ or researcher. To improve the quality of these visualizations, it is recommended
to follow some advice given by data visualization specialists on graphical semiology.

Good data visualizations, such as those in the *New York Times*, rely not only on appropriate tools (JavaScript libraries) but also on certain rules of representation that allow the message of a visualization to be understood in seconds.

This [blog post](https://blog.datawrapper.de/text-in-data-visualizations/) is a useful resource to consult regularly. 
This [blog post by Albert Rapp](https://albert-rapp.de/posts/ggplot2-tips/10_recreating_swd_look/10_recreating_swd_look) demonstrates how to gradually build a good data visualization.
:::

## Data

A subset of [Paris Open Data](https://opendata.paris.fr/explore/dataset/comptage-velo-donnees-compteurs/information/?disjunctive.id_compteur&disjunctive.nom_compteur&disjunctive.id&disjunctive.name) has been made available to facilitate import.  
It is an extraction, somewhat dated, of the original dataset where only the columns used in this exercise have been retained.

We propose downloading these data and saving them to a local file before importing them[^1]. However, we will not do this manually but rather use {{< fa brands r-project >}}. Doing this manually would be bad practice in terms of reproducibility.


```{r}
#| echo: true
url <- "https://minio.lab.sspcloud.fr/projet-formation/diffusion/python-datascientist/bike.csv"
download.file(url, "bike.gz") # <1>
```

1. The `.gz` extension is important because `readr` needs it to understand that the file is compressed.

## Initial graphical outputs

Trying to produce a perfect visualization on the first attempt is unrealistic. It is more realistic to gradually improve a graphic representation to highlight structural effects in a dataset step by step.

We will therefore start by representing the distribution of traffic at the main measurement stations.  
To do this, we will quickly produce a _barplot_ and then improve it gradually.

In this section, we will reproduce the first two charts from the [data analysis page](https://opendata.paris.fr/explore/dataset/comptage-velo-donnees-compteurs/dataviz/?disjunctive.id_compteur&disjunctive.nom_compteur&disjunctive.id&disjunctive.name): *The 10 counters with the highest hourly average* and *The 10 counters with the highest total counts*. The numeric values in the plots will differ from those on the online page, which is normal because we are working with older data.

[^1]: Normally, we recommend using the download URL directly to avoid creating an intermediate file on the disk. However, direct import with `readr` will not work here because the library does not recognize that the file is compressed without the `.gz` extension.

::: {.callout-tip}
## Exercise 1: Import the data and produce an initial plot

The data contains several dimensions suitable for statistical analysis. Therefore, it is necessary first to summarize them with aggregations to create a readable plot.

1. Import the bike counter data from the `bike.gz` file;
2. Keep the ten counters with the highest average;

```{r}
#| output: false
df <- readr::read_csv("bike.gz") %>% 
  rename(
    `counter_id` = `Identifiant du compteur`,
    `Counter name` = `Nom du compteur`,
    `counting_site_id` = `Identifiant du site de comptage`,
    `counting_site_name` = `Nom du site de comptage`,
    `Hourly count` = `Comptage horaire`,
    `Counting date and time` = `Date et heure de comptage`,
    `counting_site_installation_date` = `Date d'installation du site de comptage`)
```


```{r}
df1 <- df %>%
  group_by(`Counter name`) %>%
  summarise(`Hourly count` = mean(`Hourly count`, na.rm = TRUE)) %>%
  arrange(desc(`Hourly count`)) %>%
  head(10)
```

<details>
<summary>
The 10 main stations after step 2
</summary>
```{r}
head(df1)
```
</details>

We can now focus on producing the graphic

3. First, without worrying about style or aesthetics, create the basic structure of the _barplot_ from the [data analysis page](https://opendata.paris.fr/explore/dataset/comptage-velo-donnees-compteurs/dataviz/?disjunctive.id_compteur&disjunctive.nom_compteur&disjunctive.id&disjunctive.name):

<details>
<summary>
Initial figure without style
</summary>
```{r}
ggplot(df1, aes(y = `Counter name`, x = `Hourly count`)) +
  geom_bar(stat = "identity")
```
</details>

The next step is to gradually improve this representation to reproduce the version on the Paris Open Data page. The goal is to make it understandable in broad terms before focusing on aesthetics.

4. First, reorder the bars on the y-axis using the `reorder` function. This makes the figure's message more readable.

<details>
<summary>
Figure with reordered bars
</summary>

```{r}
figure1 <- ggplot(df1,
       aes(y = reorder(`Counter name`, `Hourly count`), # <1>
           x = `Hourly count`)
       ) +
  geom_bar(stat = "identity")
figure1
```
1. Reorder `Counter Name` according to `Hourly Count`

</details>


5. Modify the aesthetic layer to apply a red color to all bars

<details>
<summary>
Figurewith red bars
</summary>

```{r}
figure1 <- ggplot(df1,
       aes(y = reorder(`Counter name`, `Hourly count`), # <1>
           x = `Hourly count`)
       ) +
  geom_bar(stat = "identity", fill = "red")
figure1
```

</details>

:::


We now have a representation that starts to convey a message about the data. 
However, there are still problematic elements (e.g., labels) as well as missing 
or incorrect elements (axis titles, chart title, etc.).


::: {.callout-tip}
## Exercise 2: Adding some style

The figure now conveys a message but is still hard to read.

1. At a minimum, label the axes so someone unfamiliar with the data can understand the chart.
Use the same axis labels as in the original figure.

<details>
<summary>
Figure with labeled axes
</summary>

```{r}
figure1 <- figure1 + labs( # <1>
  title = "The 10 counters with the highest hourly average",
  x = "Counter name",
  y = "Hourly average"
)
figure1
```
1. The simplest way to label axes in `ggplot` is with the `labs` function.

</details>


2. The gray background, while characteristic of a `ggplot2` figure, is not very polished. 
Use a more minimal theme to have a white background.

<details>
<summary>
Figure with white background
</summary>
```{r}
figure1 <- figure1 +
  theme_minimal()
figure1
```

</details>

3. Next, focus on aesthetic elements. As this is slightly more advanced, we provide 
the code to update your figure with the following style elements:


```r
theme(
  axis.text.x = element_text(angle = 45, hjust = 1, color = "red"),
  axis.title.x = element_text(color = "red"),
  plot.title = element_text(hjust = 0.5),
  plot.margin = margin(1, 4, 1, 1, "cm")
)
```

<details>
<summary>
Figure after styling
</summary>
```{r}
figure1 <- figure1 +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, color = "red"),
    axis.title.x = element_text(color = "red"),
    plot.title = element_text(hjust = 0.5),
    plot.margin = margin(1, 4, 1, 1, "cm")
    )
figure1
```

4. Finally, add complexity to the plot by placing numbers on the bars. Using this [post](https://stackoverflow.com/questions/67767859/adding-text-on-each-bar-in-horizontal-bar-plot-in-ggplot2-geom-area), 
add the mean hourly counts as in the Paris Open Data figure[^annotation].


```{r}
figure1 <- figure1 + 
  geom_text(
    aes(label=round(`Hourly count`)),
    position=position_dodge(width=0.9),
    hjust=-0.5
    )
```

[^annotation]: Note: displaying numbers on bars is not necessarily best practice in _dataviz_. 
It can make the scale and data variation less immediately understandable.


</details>

:::

This shows that Boulevard de S√©bastopol is the busiest, which will not surprise 
anyone cycling in Paris. If you are not familiar with Parisian geography, additional 
visualizations, such as a map, will be needed in a later chapter.


```{r}
#| fig-cap: "The 10 counters with the highest hourly average"
figure1
```

::: {.callout-tip}
## Exercice 3: produce a new figure

Repeat the process for figure 2 (_"The 10 counters with the highest total counts"_), to create a similar chart.

<details>

```{r}
df2 <- df %>%
  group_by(`Counter name`) %>%
  summarise(`Hourly count` = sum(`Hourly count`, na.rm = TRUE)) %>%
  arrange(desc(`Hourly count`)) %>%
  head(10)
```

```{r}
# Create a horizontal bar plot
figure2 <- ggplot(df2, aes(y = reorder(`Counter name`, `Hourly count`), x = `Hourly count`)) +
  geom_bar(stat = "identity", fill = "forestgreen") +
  labs(title = "The 10 counters that recorded the most bicycles",
       x = "Name of the counter",
       y = "The total number of bikes recorded during the selected period") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        axis.title.x = element_text(color = "forestgreen"),
        plot.title = element_text(hjust = 0.5),
        plot.margin = margin(1, 4, 1, 1, "cm"))
```

<summary>
Figure 2 a the end of the exercise
</summary>

```{r}
figure2
```

</details>



:::


Barplots are extremely common, but from a semiology perspective, _lollipop charts_ 
are preferable: they convey the same information with less visual noise 
(the bar widths in barplots can obscure information).

Here is an example of the second figure rendered as a _lollipop chart_:


```{r}
df2_lollipop <- df2 %>%
  mutate(x =  fct_reorder(`Counter name`, `Hourly count` ), y = `Hourly count`)

figure2_lollipop <- ggplot(df2_lollipop, aes(x=x, y=y)) +
    geom_segment(aes(xend=x, yend=0), alpha = 0.4) +
    geom_point(size=5, color="forestgreen") +
    coord_flip() +
  labs(title = "The 10 counters that recorded the most bicycles",
       x = "Name of the counter",
       y = "The total number of bikes recorded during the selected period")  +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        axis.title.x = element_text(color = "forestgreen"),
        plot.title = element_text(hjust = 0.5),
        plot.margin = margin(1, 4, 1, 1, "cm")) +
  scale_y_continuous(labels = unit_format(unit = "M", scale=1e-6))
```

```{r}
figure2_lollipop
```

<details>
<summary>
Comparison of _barplot_ and _lollipop chart_
</summary>
```{r}
#| layout-ncol: 2
#| fig-cap: "Choose your preferred representation"
#| fig-subcap: 
#|   - "Barplot"
#|   - "Lollipop"
figure2
figure2_lollipop
```
</details>


::: {.callout-tip}
## Exercice 3 bis (optional): Produce a _lollipop_ chart

Reprendre l'exercice 2 mais √† la place d'un _barplot_, produire
un _lollipop chart_.  
::: 

## First temporal aggregation

We now focus on the spatial dimension of the dataset using two approaches:

  - A bar chart summarizing the data monthly;
  - Time series illustrating temporal dynamics (next section).


To start, reproduce the third figure, again a _barplot_. The first step introduces 
time data and involves a common operation in time series: changing the date format 
to allow aggregation at a larger time interval. 

::: {.callout-tip}
## Exercice 4: monthly count barplot

1. Use the `format` function to create a `month` variable in the `YYYY-MM` format ;
2. Compute the mean hourly counts for each month

```{r}
df <- df %>%
  mutate(month = format(`Counting date and time`, "%Y-%m"))
```

```{r}
# Question 2
monthly_hourly_count <- df %>%
  group_by(month) %>%
  summarise(value = mean(`Hourly count`, na.rm = TRUE))
```

<details>
<summary>
Hourly counts obtained after this step
</summary>

```{r}
monthly_hourly_count
```

</details>

Apply previous recommendations to gradually construct and improve a chart similar
to the third figure on the Paris _Open Data_ page.

```{r}
figure3 <- ggplot(monthly_hourly_count) +
  geom_bar(aes(x = month, y = value), fill = "#ffcd00", stat = "identity") +
  labs(x = "Date and time of count", y = "Average hourly count per month\nover the selected period",
       title = "Average monthly bicycle counts") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        axis.title.y = element_text(color = "#ffcd00", face = "bold"),
        plot.title = element_text(hjust = 0.5),
        plot.margin = margin(1, 4, 1, 1, "cm"))
```

<details>
<summary>
Example figure reproducing Paris _Open Data_
</summary>

```{r}
figure3
```

</details>

- Optional: represent the same information as _lollipop_ chart

:::


```{r}
figure3
```

If you rather present this with a _lollipop_[^notecouleur] chart:

```{r}
ggplot(monthly_hourly_count, aes(x = month, y = value)) +
  geom_segment(aes(xend = month, yend = 0)) +
  geom_point(color="#ffcd00", size=4) +
  labs(x = "Counting date and time", y = "Average hourly count per month\nover the selected period",
       title = "Average monthly bicycle counts") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        #axis.title.y = element_text(color = "#ffcd00", face = "bold"),
        plot.title = element_text(hjust = 0.5),
        plot.margin = margin(1, 4, 1, 1, "cm"))
```

[^notecouleur]: I removed the color on the y-axis, which I find
adds little to the figure and even detracts from the message's clarity. 


## First time series

Time series visualizations are more common for data with a temporal dimension.


::: {.callout-tip}
## Exercice 5: Time series representation

1. Create a `day` variable converting timestamps to daily format (e.g. `2021-05-01`).

```{r}
df <- df %>%
  mutate(day = date(`Counting date and time`))

daily_average <- df %>%
  group_by(day) %>%
  summarise(value = mean(`Hourly count`, na.rm = TRUE))
```

2. Plot this as a time series without worrying about styling;

```{r}
figure4 <- ggplot(daily_average, aes(x = day, y = value)) +
  geom_line(color = "magenta")
```

<details>
<summary>
Figure minimaliste
</summary>
```{r}
figure4
```
</details>

3. Fill the area under the line using the appropriate function;

```{r}
figure4 <- figure4 +
  geom_area(fill="magenta", alpha = 0.6)
```

<details>
<summary>
Figure avec la coloration sous la ligne
</summary>
```{r}
figure4
```
</details>

4. Finalize the plot to reproduce the Paris _Open Data_ figure;

```{r}
figure4 <- figure4 +
  labs(x = "Counting date and time (Day)", y = "Average hourly count per day\nover the selected period",
       title = "Average daily bicycle counts") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        plot.title = element_text(hjust = 0.5),
        plot.margin = margin(1, 4, 1, 1, "cm"))
```

<details>
<summary>
Figure with filled area
</summary>
```{r}
figure4
```
</details>

Some hints for this exercise


<details>
<summary>
üí° Hint for question 1
</summary>
Look up the `day` function of the `lubridate` _package_
</details>

<details>
<summary>
üí° Hint for question 1
</summary>
[This `stackoverflow` _thread_](https://stackoverflow.com/questions/28730083/filling-in-the-area-under-a-line-graph-in-ggplot2-geom-area) might help you out.
</details>


<details>
<summary>
Data for Figure 4
</summary>
```{r}
head(daily_average)
```
</details>

:::

After this exercise, the figure will look like this:

```{r}
figure4
```


## Introduction to HTML plots with `Plotly`

The drawback of `ggplot` figures is that they are not interactive. All information 
must be included in the plot, which can make it harder to read. If well done, 
a multi-level information plot can still work.

With web technologies, it is easier to offer multi-level visualizations: 
a first glance conveys the main message, and the user can explore additional details interactively. 
Interactive visualizations, now standard in dataviz, allow the reader to hover for more information 
or click to reveal additional details.

These visualizations rely on the web triptych: `HTML`, `CSS`, and `JavaScript`. 
{{< fa brands r-project >}} users do not manipulate these languages directly, 
but use R libraries that automatically generate the necessary code. 

::: {.callout-tip}
## Exercice 6: interactive time series

1. Create a basic `Plotly` figure representing figure 4 as a time series without worrying about style.

<details>
<summary>
Time series figure without styling
</summary>
```{r}
plot_ly(
  daily_average, x = ~day, y = ~value,
  type = 'scatter', mode = 'lines'
)
```
</details>


2. Using the [documentation](https://plotly.com/r/filled-area-plots/),
add an area under the curve;

<details>
<summary>
Add area under the line
</summary>

```{r}
plot_ly(
  daily_average, x = ~day, y = ~value,
  fill = 'tozeroy',
  type = 'scatter', mode = 'lines'
)
```
</details>


3. Adjust styling elements to reproduce figure 4. Use `hovertemplate` and `hoverinfo` to enhance interactivity.

```{r}
fig <- plot_ly(
  daily_average, x = ~day, y = ~value,
  color = I("magenta"),
  hovertemplate = ~paste(day, ": ", round(value), " bicycle passages per hour on average"),
  hoverinfo = "text",
  fill = 'tozeroy',
  type = 'scatter', mode = 'lines')
fig4 <- fig %>%
  layout(title = "Average daily bicycle counts",
         xaxis = list(title = "Counting date and time (Day)"),
         yaxis = list(title = "Average hourly count per day\nover the selected period"))
```


<details>
<summary>
Figure obtenue
</summary>

```{r}
fig4
```

</details>

:::


The interactive version is then produced.

```{r}
fig4
```


This shows the special characteristics of 2020. To highlight the first lockdown visible in the data, vertical lines can be added using [documentation](https://plotly.com/r/horizontal-vertical-shapes/).

```{r}
#| echo: true
vline <- function(x = 0, color = "royalblue") {
  list(
    type = "line",
    y0 = 0,
    y1 = 1,
    yref = "paper",
    x0 = x,
    x1 = x,
    line = list(color = color, dash="dot")
  )
}

fig4 %>% layout(shapes = list(vline("2020-03-17"), vline("2020-05-11")))
```

Finally, here‚Äôs how to reproduce this figure with `Plotly`:

```{r}
df1 <- df1 %>% mutate(`Counter name` = fct_reorder(`Counter name`, `Hourly count`))

fig <- plot_ly(
  df1,
  x = ~ `Hourly count`, y = ~`Counter name`,
  color = I("red"),
  hovertext = ~paste0(`Counter name`, ": ", round(`Hourly count`)),
  hoverinfo = 'text',
  type = 'bar',
  name = 'Main stations')


fig <- fig %>% layout(
  yaxis = list(title = 'Hourly average'),
  xaxis = list(title = 'Counter name', color = "red")
  )
```


```{r}
fig
```

::: {.callout-tip}
## Exercice 7: barplot with `Plotly`

1. To order bars correctly, use `fct_reorder` from `forcats` on the dataframe from exercise 1;
2. Use `Plotly` to create your figure;
3. (Optional, advanced) Produce a _lollipop chart_ with `Plotly`
:::


---
title: "Data visualisation with {{< fa brands r-project >}} and `ggplot2`"
echo: true
number-sections: true
---

::: {.badge}
<a href="https://datalab.sspcloud.fr/launcher/ide/rstudio?autoLaunch=false&networking.user.enabled=true&onyxia.friendlyName=%C2%ABrstudio-cours-ENS%C2%BB" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/Tester%20via%20SSP%20cloud%20-%20SSPCloud?logo=R&labelColor=black&color=%231965b8" alt="Onyxia"></a><br>
:::

<details>
<summary>
Check out the _slides_ below or [click here](/slides/ggplot.qmd)
to view the slides in full screen.
</summary>


``` {.yaml code-preview="/slides/ggplot.qmd"}
```

</details>


In this practical session,
We will learn how to create synthetic graphical representations with {{< fa brands r-project >}}, which is very well equipped for this task thanks to the `ggplot2` library. This library implements a [grammar of graphics](https://fr.wikibooks.org/wiki/Programmer_en_R/Comprendre_la_grammaire_des_graphiques) that is flexible, consistent, and easy to use.

If you are interested in `Python` {{< fa brands python >}}, a very similar version of this practical session is available in [my ENSAE course](https://pythonds.linogaliana.fr/content/visualisation/matplotlib.html).


::: {.callout-note}

Some code examples have annotations on the side; hover your mouse over them to display the notes, like below:


```{r}
#| echo: true
#| output: false
"une annotation explicative m'accompagne √† droite" #<1>
```
1. I appear when you hover your mouse over me üê≠ !

:::

In this course, the practice of visualization will involve replicating charts found on
the Paris *Open Data* page [here](https://opendata.paris.fr/explore/dataset/comptage-velo-donnees-compteurs/dataviz/?disjunctive.id_compteur&disjunctive.nom_compteur&disjunctive.id&disjunctive.name).

This practical session aims to introduce:

* Mainly the [`ggplot2`](https://ggplot2.tidyverse.org/) package for creating static plots;
* The [`plotly`](https://plotly.com/r/) package for interactive HTML plots. We will deepen our knowledge of HTML plots in a later chapter using [`Observable`](https://observablehq.com/).

In this chapter, we will use the following libraries:

```{r}
#| echo: true
#| output: false
library(scales)
library(readr)
library(dplyr)
library(forcats)
library(lubridate)
library(ggplot2)
library(plotly)
```


Then, we will see how to easily create maps in equivalent formats.

::: {.callout-note}
Being able to create interesting data visualizations is an essential skill for any
_data scientist_ or researcher. To improve the quality of these visualizations, it is recommended
to follow some advice given by data visualization specialists on graphical semiology.

Good data visualizations, such as those in the *New York Times*, rely not only on appropriate tools (JavaScript libraries) but also on certain rules of representation that allow the message of a visualization to be understood in seconds.

This [blog post](https://blog.datawrapper.de/text-in-data-visualizations/) is a useful resource to consult regularly. 
This [blog post by Albert Rapp](https://albert-rapp.de/posts/ggplot2-tips/10_recreating_swd_look/10_recreating_swd_look) demonstrates how to gradually build a good data visualization.
:::

## Data

A subset of [Paris Open Data](https://opendata.paris.fr/explore/dataset/comptage-velo-donnees-compteurs/information/?disjunctive.id_compteur&disjunctive.nom_compteur&disjunctive.id&disjunctive.name) has been made available to facilitate import.  
It is an extraction, somewhat dated, of the original dataset where only the columns used in this exercise have been retained.

We propose downloading these data and saving them to a local file before importing them[^1]. However, we will not do this manually but rather use {{< fa brands r-project >}}. Doing this manually would be bad practice in terms of reproducibility.


```{r}
#| echo: true
url <- "https://minio.lab.sspcloud.fr/projet-formation/diffusion/python-datascientist/bike.csv"
download.file(url, "bike.gz") # <1>
```

1. The `.gz` extension is important because `readr` needs it to understand that the file is compressed.

## Initial graphical outputs

Trying to produce a perfect visualization on the first attempt is unrealistic. It is more realistic to gradually improve a graphic representation to highlight structural effects in a dataset step by step.

We will therefore start by representing the distribution of traffic at the main measurement stations.  
To do this, we will quickly produce a _barplot_ and then improve it gradually.

In this section, we will reproduce the first two charts from the [data analysis page](https://opendata.paris.fr/explore/dataset/comptage-velo-donnees-compteurs/dataviz/?disjunctive.id_compteur&disjunctive.nom_compteur&disjunctive.id&disjunctive.name): *The 10 counters with the highest hourly average* and *The 10 counters with the highest total counts*. The numeric values in the plots will differ from those on the online page, which is normal because we are working with older data.

[^1]: Normally, we recommend using the download URL directly to avoid creating an intermediate file on the disk. However, direct import with `readr` will not work here because the library does not recognize that the file is compressed without the `.gz` extension.

::: {.callout-tip}
## Exercise 1: Import the data and produce an initial plot

The data contains several dimensions suitable for statistical analysis. Therefore, it is necessary first to summarize them with aggregations to create a readable plot.

1. Import the bike counter data from the `bike.gz` file;
2. Keep the ten counters with the highest average;

```{r}
#| output: false
df <- readr::read_csv("bike.gz")
```


```{r}
df1 <- df %>%
  group_by(`Nom du compteur`) %>%
  summarise(`Comptage horaire` = mean(`Comptage horaire`, na.rm = TRUE)) %>%
  arrange(desc(`Comptage horaire`)) %>%
  head(10)
```

<details>
<summary>
The 10 main stations after step 2
</summary>
```{r}
head(df1)
```
</details>

On va maintenant pouvoir se concentrer sur la production de la 
repr√©sentation

3. En premier lieu, sans se pr√©occuper des √©l√©ments de style ni de la beaut√©
du graphique, cr√©er la structure du _barplot_ (diagramme en batons) de la
[page d'analyse des donn√©es](https://opendata.paris.fr/explore/dataset/comptage-velo-donnees-compteurs/dataviz/?disjunctive.id_compteur&disjunctive.nom_compteur&disjunctive.id&disjunctive.name):

<details>
<summary>
Figure obtenue, sans s'occuper du style
</summary>
```{r}
ggplot(df1, aes(y = `Nom du compteur`, x = `Comptage horaire`)) +
  geom_bar(stat = "identity")
```
</details>

La suite de l'exercice consiste √† am√©liorer graduellement cette repr√©sentation
pour converger vers la reproduction de la version en _open data_. Il
ne s'agit pas encore de se concentrer sur l'esth√©tique de la figure mais
de la rendre intelligible, √† gros trait. 

4. En premier lieu, r√©ordonner les barres sur l'axe des ordonn√©es
gr√¢ce √† la fonction `reorder`. Cela rendra le message de la figure
plus intelligible. 

<details>
<summary>
Figure avec les barres r√©ordonn√©es
</summary>

```{r}
figure1 <- ggplot(df1,
       aes(y = reorder(`Nom du compteur`, `Comptage horaire`), # <1>
           x = `Comptage horaire`)
       ) +
  geom_bar(stat = "identity")
figure1
```
1. On r√©ordonne `Nom du compteur` en fonction de `Comptage horaire`

</details>


5. Modifier votre couche esth√©tique afin
d'appliquer une couleur rouge √† l'ensemble des barres

<details>
<summary>
Figure avec les barres rouges
</summary>

```{r}
figure1 <- ggplot(df1,
       aes(y = reorder(`Nom du compteur`, `Comptage horaire`), # <1>
           x = `Comptage horaire`)
       ) +
  geom_bar(stat = "identity", fill = "red")
figure1
```

</details>

:::

On commence √† avoir quelque chose qui commence √† transmettre
un message synth√©tique sur la nature des donn√©es.
On peut n√©anmoins remarquer plusieurs √©l√©ments probl√©matiques
(par exemple les labels) mais
aussi des √©l√©ments ne correspondant pas (les titres des axes, etc.) ou 
manquants (le nom du graphique...)


::: {.callout-tip}
## Exercice 2 : Un peu de style !

La figure comporte maintenant un message mais il est encore peu
lisible. 

1. Le minimum pour que quelqu'un ne connaissant pas les donn√©es soit
capable de comprendre la repr√©sentation graphique est de labelliser
les axes. Cr√©er les m√™mes labels d'axes que la figure originale. 

<details>
<summary>
Figure avec les axes nomm√©s
</summary>

```{r}
figure1 <- figure1 + labs( # <1>
  title = "Les 10 compteurs avec la moyenne horaire la plus √©lev√©e",
  x = "Nom du compteur",
  y = "Moyenne horaire"
)
figure1
```
1. Il existe de nombreuses mani√®res de proc√©der avec `ggplot` pour labelliser
les axes. Mais la plus simple est la fonction `labs`

</details>


2. Le fond gris permet est certes une marque distinctive que le graphique a √©t√©
produit avec `ggplot2` mais ce n'est pas tr√®s soign√©.
Utiliser un th√®me plus minimaliste afin d'avoir un fond blanc.

<details>
<summary>
Figure avec un fond blanc
</summary>
```{r}
figure1 <- figure1 +
  theme_minimal()
figure1
```

</details>

3. Maintenant, concentrons nous sur les √©l√©ments plus esth√©tiques.
Comme c'est une fonctionnalit√© un peu plus avanc√©e, nous proposons directement
le code pour mettre √† jour votre figure avec les √©l√©ments de style
suivant:

```r
theme(
  axis.text.x = element_text(angle = 45, hjust = 1, color = "red"),
  axis.title.x = element_text(color = "red"),
  plot.title = element_text(hjust = 0.5),
  plot.margin = margin(1, 4, 1, 1, "cm")
)
```

<details>
<summary>
Figure obtenue √† l'issue de ces questions
</summary>
```{r}
figure1 <- figure1 +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, color = "red"),
    axis.title.x = element_text(color = "red"),
    plot.title = element_text(hjust = 0.5),
    plot.margin = margin(1, 4, 1, 1, "cm")
    )
figure1
```

4. Enfin ajoutons de la complexit√© au graphique avec les chiffres sur
les barres.
En vous aidant de ce [_post_](https://stackoverflow.com/questions/67767859/adding-text-on-each-bar-in-horizontal-bar-plot-in-ggplot), ajouter les comptages horaires moyens comme sur la
figure de l'_open data_ parisien[^annotation]

```{r}
figure1 <- figure1 + 
  geom_text(
    aes(label=round(`Comptage horaire`)),
    position=position_dodge(width=0.9),
    hjust=-0.5
    )
```

[^annotation]: Ce n'est pas forc√©ment une bonne pratique de _dataviz_ de
faire cela. En effet, cela signifie que l'√©chelle et la diversit√©
des donn√©es dans celle-ci ne sont pas directement 
intelligibles. 

</details>

:::

On comprend
ainsi que le boulevard de S√©bastopol est le plus emprunt√©,
ce qui ne vous suprendra pas si vous faites du v√©lo √† Paris. 
N√©anmoins, si vous n'√™tes pas familiers avec la g√©ographie parisienne,
cela sera peu informatif pour vous, vous allez avoir besoin d'une
repr√©sentation graphique suppl√©mentaire: une carte ! Nous verrons
ceci lors d'un prochain chapitre. 

```{r}
#| fig-cap: "Les 10 compteurs avec la moyenne horaire la plus √©lev√©e"
figure1
```

::: {.callout-tip}
## Exercice 3: produire une nouvelle figure

Faire la m√™me chose pour la figure 2 (_"Les 10 compteurs ayant comptabilis√©s le plus de v√©los"_), afin d'obtenir une figure similaire.

<details>

```{r}
df2 <- df %>%
  group_by(`Nom du compteur`) %>%
  summarise(`Comptage horaire` = sum(`Comptage horaire`, na.rm = TRUE)) %>%
  arrange(desc(`Comptage horaire`)) %>%
  head(10)
```

```{r}
# Create a horizontal bar plot
figure2 <- ggplot(df2, aes(y = reorder(`Nom du compteur`, `Comptage horaire`), x = `Comptage horaire`)) +
  geom_bar(stat = "identity", fill = "forestgreen") +
  labs(title = "Les 10 compteurs ayant comptabilis√©s le plus de v√©los",
       x = "Nom du compteur",
       y = "La somme des v√©los comptabilis√©s sur la p√©riode s√©lectionn√©e") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        axis.title.x = element_text(color = "forestgreen"),
        plot.title = element_text(hjust = 0.5),
        plot.margin = margin(1, 4, 1, 1, "cm"))
```

<summary>
Figure 2 √† l'issue de cet exercice
</summary>

```{r}
figure2
```

</details>



:::


Les diagrammes en batons (_barplot_) sont extr√™mement communs mais 
qu'ils transmettent. Sur le plan s√©miologique,
les _lollipop charts_ sont pr√©f√©rables: ils
transmettent la m√™me information mais avec moins de bruit
(la largeur des barres du barplot noie un peu l'information).

Voici, par exemple, la deuxi√®me figure de la page, rendue non plus
sous forme de _barplot_ mais sous forme de _lollipop chart_:


```{r}
df2_lollipop <- df2 %>%
  mutate(x =  fct_reorder(`Nom du compteur`, `Comptage horaire` ), y = `Comptage horaire`)

figure2_lollipop <- ggplot(df2_lollipop, aes(x=x, y=y)) +
    geom_segment( aes(xend=x, yend=0), alpha = 0.4) +
    geom_point( size=5, color="forestgreen") +
    coord_flip() +
  labs(title = "Les 10 compteurs ayant comptabilis√©s le plus de v√©los",
       x = "Nom du compteur",
       y = "La somme des v√©los comptabilis√©s sur la p√©riode s√©lectionn√©e") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        axis.title.x = element_text(color = "forestgreen"),
        plot.title = element_text(hjust = 0.5),
        plot.margin = margin(1, 4, 1, 1, "cm")) +
  scale_y_continuous(labels = unit_format(unit = "M", scale=1e-6))
```

```{r}
figure2_lollipop
```

<details>
<summary>
Comparaison du _barplot_ et du _lollipop chart_
</summary>
```{r}
#| layout-ncol: 2
#| fig-cap: "Choisissez votre repr√©sentation pr√©f√©r√©e"
#| fig-subcap: 
#|   - "Barplot"
#|   - "Lollipop"
figure2
figure2_lollipop
```
</details>


::: {.callout-tip}
## Exercice 3 bis (optionnel): produire un _lollipop_ chart

Reprendre l'exercice 2 mais √† la place d'un _barplot_, produire
un _lollipop chart_.  
::: 

## Premi√®re agr√©gation temporelle

On va maintenant se concentrer sur la dimension spatiale de notre
jeu de donn√©es √† travers deux approches:

- Un diagramme en barre synth√©tisant l'information de notre jeu de donn√©es
de mani√®re mensuelle ;
- Des s√©ries instructives sur la dynamique temporelle. Cela sera l'objet de la prochaine partie ;


Pour commencer, reproduisons la troisi√®me figure qui est, encore une fois, 
un _barplot_. La premi√®re question implique une premi√®re rencontre avec
une donn√©e temporelle √† travers une op√©ration assez classique en s√©ries
temporelles: changer le format d'une date pour pouvoir faire une agr√©gation
√† un pas de temps plus large. 

::: {.callout-tip}
## Exercice 4: barplot des comptages mensuels

1. Utiliser la fonction `format` pour cr√©er une variable `month`
dont le format respecte, par exemple, le sch√©ma `2019-08` ;
2. Faire la moyenne des comptages horaires pour chaque mois

```{r}
df <- df %>%
  mutate(month = format(`Date et heure de comptage`, "%Y-%m"))
```

```{r}
# Question 2
comptage_horaires_mois <- df %>%
  group_by(month) %>%
  summarise(value = mean(`Comptage horaire`, na.rm = TRUE))
```

<details>
<summary>
Comptages horaires obtenus √† l'issue de cette question
</summary>

```{r}
comptage_horaires_mois
```

</details>

Appliquer les conseils pr√©c√©dents pour construire et am√©liorer
graduellement un graphique afin d'obtenir une figure similaire
√† la 3e production sur la page de l'_open data_ parisien.

```{r}
figure3 <- ggplot(comptage_horaires_mois) +
  geom_bar(aes(x = month, y = value), fill = "#ffcd00", stat = "identity") +
  labs(x = "Date et heure de comptage", y = "Moyenne mensuelle du comptage par heure\nsur la p√©riode s√©lectionn√©e",
       title = "Moyenne mensuelle des comptages v√©los") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        axis.title.y = element_text(color = "#ffcd00", face = "bold"),
        plot.title = element_text(hjust = 0.5),
        plot.margin = margin(1, 4, 1, 1, "cm"))
```

<details>
<summary>
Exemple de figure reproduisant l'_open data_ parisien
</summary>

```{r}
figure3
```

</details>

- Question optionnelle: repr√©senter la m√™me information sous forme de _lollipop_

:::


```{r}
figure3
```

Si vous pr√©f√©rez repr√©senter cela sous forme de _lollipop_[^notecouleur]:

```{r}
ggplot(comptage_horaires_mois, aes(x = month, y = value)) +
  geom_segment(aes(xend = month, yend = 0)) +
  geom_point( color="#ffcd00", size=4) +
  labs(x = "Date et heure de comptage", y = "Moyenne mensuelle du comptage par heure\nsur la p√©riode s√©lectionn√©e",
       title = "Moyenne mensuelle des comptages v√©los") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        #axis.title.y = element_text(color = "#ffcd00", face = "bold"),
        plot.title = element_text(hjust = 0.5),
        plot.margin = margin(1, 4, 1, 1, "cm"))
```

[^notecouleur]: J'ai retir√© la couleur sur l'axe des ordonn√©es qui, je trouve,
apporte peu √† la figure voire d√©grade la compr√©hension du message. 


## Premi√®re s√©rie temporelle

Il est plus commun de repr√©senter sous forme de s√©rie
les donn√©es ayant une dimension temporelle.


::: {.callout-tip}
## Exercice 5: Repr√©senter une s√©rie temporelle

1. Cr√©er une variable `day` qui transforme l'horodatage en format journalier
du type `2021-05-01`.

```{r}
df <- df %>%
  mutate(day = date(`Date et heure de comptage`))

moyenne_quotidienne <- df %>%
  group_by(day) %>%
  summarise(value = mean(`Comptage horaire`, na.rm = TRUE))
```

2. Repr√©senter sous forme de s√©rie temporelle cette information, sans vous
pr√©occuper du style de la figure.

```{r}
figure4 <- ggplot(moyenne_quotidienne, aes(x = day, y = value)) +
  geom_line(color = "magenta")
```

<details>
<summary>
Figure minimaliste
</summary>
```{r}
figure4
```
</details>

3. Colorer la zone sous la ligne avec la fonction appropri√©e

```{r}
figure4 <- figure4 +
  geom_area(fill="magenta", alpha = 0.6)
```

<details>
<summary>
Figure avec la coloration sous la ligne
</summary>
```{r}
figure4
```
</details>

4. Finaliser le graphique pour reproduire la figure de la page d'_open data_

```{r}
figure4 <- figure4 +
  labs(x = "Date et heure de comptage (Jour)", y = "Moyenne journali√®re du comptage par heure\nsur la p√©riode s√©lectionn√©e",
       title = "Moyenne journali√®re des comptages v√©los") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        plot.title = element_text(hjust = 0.5),
        plot.margin = margin(1, 4, 1, 1, "cm"))
```

<details>
<summary>
Figure finalis√©e
</summary>
```{r}
figure4
```
</details>

Voici quelques aides pour cet exercice


<details>
<summary>
üí° Aide pour la question 1
</summary>
Regardez la fonction `day` du _package_ `lubridate`
</details>

<details>
<summary>
üí° Aide pour la question 3
</summary>
[Ce _thread_ sur `stackoverflow`](https://stackoverflow.com/questions/28730083/filling-in-the-area-under-a-line-graph-in-ggplot2-geom-area) peut vous aider.
</details>


<details>
<summary>
Le jeu de donn√©es pour la figure 4
</summary>
```{r}
head(moyenne_quotidienne)
```
</details>

:::

A l'issue de cet exercice, on obtient ainsi une figure prenant la forme
suivante:

```{r}
figure4
```


## Introduction aux graphiques HTML avec `Plotly`

L'inconv√©nient des figures avec `ggplot` est que celles-ci ne permettent
pas d'interaction avec le lecteur. Toute l'information doit donc √™tre
contenue dans la figure ce qui peut la rendre difficile √† lire. 
Si la figure est bien faite, avec diff√©rents niveaux d'information, cela
peut bien fonctionner.

Il est n√©anmoins plus simple, gr√¢ce aux technologies _web_, de proposer des
visualisations √† plusieurs niveaux. Un premier niveau d'information, celui du
coup d'oeil, peut suffire √† assimiler les principaux messages de la
visualisation. Ensuite, un comportement plus volontaire de recherche
d'information secondaire peut permettre d'en savoir plus. Les visualisations
r√©actives, qui sont maintenant la norme dans le monde de la _dataviz_, 
permettent ce type d'approche: le lecteur d'une visualisation peut passer
sa souris √† la recherche d'information compl√©mentaire (par exemple les
valeurs exactes) ou cliquer pour faire appara√Ætre des informations compl√©mentaires
sur la visualisation ou autour.

Ces visualisations reposent sur le m√™me triptyque que l'ensemble de l'√©cosyst√®me
_web_: `HTML`, `CSS` et `JavaScript`. Les utilisateurs de {{< fa brands r-project >}} 
ne vont jamais manipuler directement ces langages, qui demandent une 
certaine expertise, mais vont utiliser des librairies au niveau de {{< fa brands r-project >}} qui g√©n√®reront automatiquement tout le code `HTML`, `CSS` et `JavaScript`
permettant de cr√©er la figure. 

::: {.callout-tip}
## Exercice 6: s√©rie temporelle interactive

1. Cr√©er une figure `Plotly` basique pour repr√©senter
sous forme de s√©rie temporelle la figure 4, sans se pr√©occuper du style

<details>
<summary>
S√©rie temporelle produite sans √©l√©ment de style
</summary>
```{r}
plot_ly(
  moyenne_quotidienne, x = ~day, y = ~value,
  type = 'scatter', mode = 'lines'
)
```
</details>


2. A partir de l'exemple dans la [documentation](https://plotly.com/r/filled-area-plots/),
ajouter une aire sous la figure

<details>
<summary>
Ajout de la couche sous la ligne
</summary>

```{r}
plot_ly(
  moyenne_quotidienne, x = ~day, y = ~value,
  fill = 'tozeroy',
  type = 'scatter', mode = 'lines'
)
```
</details>


3. Jouer sur les √©l√©ments de style pour reproduire la figure 4. Pour profiter
de la r√©activit√© du graphique, soigner l'information obtenue en passant
la souris sur la figure gr√¢ce aux arguments `hovertemplate` et `hoverinfo`

```{r}
fig <- plot_ly(
  moyenne_quotidienne, x = ~day, y = ~value,
  color = I("magenta"),
  hovertemplate = ~paste(day, ": ", round(value), " passages de v√©lo en moyenne par heure"),
  hoverinfo = "text",
  fill = 'tozeroy',
  type = 'scatter', mode = 'lines')
fig4 <- fig %>%
  layout(title = "Moyenne journali√®re des comptages v√©los",
         xaxis = list(title = "Date et heure de comptage (Jour)"),
         yaxis = list(title = "Moyenne journali√®re du comptage par heure\nsur la p√©riode s√©lectionn√©e"))
```


<details>
<summary>
Figure obtenue
</summary>

```{r}
fig4
```

</details>

:::


La version r√©active de la figure est ainsi

```{r}
fig4
```


Cette repr√©sentation montre bien le caract√®re sp√©cial de l'ann√©e 2020. Pour 
rappeller au lecteur distrait la nature particuli√®re de la p√©riode, marqu√©e
par un premier confinement qu'on voit bien dans les donn√©es, on peut,
avec l'aide de la [documentation](https://plotly.com/r/horizontal-vertical-shapes/),
ajouter deux barres verticales pour marquer les dates de d√©but et
de fin de cette p√©riode:


```{r}
#| echo: true
vline <- function(x = 0, color = "royalblue") {
  list(
    type = "line",
    y0 = 0,
    y1 = 1,
    yref = "paper",
    x0 = x,
    x1 = x,
    line = list(color = color, dash="dot")
  )
}

fig4 %>% layout(shapes = list(vline("2020-03-17"), vline("2020-05-11")))
```

Comme dernier exercice, voici comment reproduire cette figure avec 
`Plotly`:

```{r}
df1 <- df1 %>% mutate(`Nom du compteur` = fct_reorder(`Nom du compteur`, `Comptage horaire`))

fig <- plot_ly(
  df1,
  x = ~ `Comptage horaire`, y = ~`Nom du compteur`,
  color = I("red"),
  hovertext = ~paste0(`Nom du compteur`, ": ", round(`Comptage horaire`)),
  hoverinfo = 'text',
  type = 'bar',
  name = 'Principales stations')


fig <- fig %>% layout(
  yaxis = list(title = 'Moyenne horaire'),
  xaxis = list(title = 'Nom du compteur', color = "red")
  )
```


```{r}
fig
```

::: {.callout-tip}
## Exercice 7: un barplot avec `Plotly`

1. Pour avoir imm√©diatement des barres bien ordonn√©es, utiliser la fonction
`fct_reorder` du package `forcats` pour r√©oordonner les valeurs du dataframe
issu de l'exercice 1
2. Utiliser `Plotly` pour cr√©er votre figure.
3. (Optionnel, plus avanc√©) Faire un _lollipop chart_ avec `Plotly`
:::


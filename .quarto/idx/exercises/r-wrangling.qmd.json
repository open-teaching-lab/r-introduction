{"title":"Importer et manipuler des donn√©es avec {{< fa brands r-project >}}","markdown":{"yaml":{"title":"Importer et manipuler des donn√©es avec {{< fa brands r-project >}}","echo":true,"number-sections":true},"headingText":"Etapes pr√©liminaires: installer les _packages_","containsRefs":false,"markdown":"\n\n::: {.badge}\n<a href=\"https://datalab.sspcloud.fr/launcher/ide/rstudio?autoLaunch=false&networking.user.enabled=true&onyxia.friendlyName=%C2%ABrstudio-cours-ENS%C2%BB\" target=\"_blank\" rel=\"noopener\"><img src=\"https://img.shields.io/badge/Tester%20via%20SSP%20cloud%20-%20SSPCloud?logo=R&labelColor=black&color=%231965b8\" alt=\"Onyxia\"></a><br>\n:::\n\n<details>\n<summary>\nD√©rouler les _slides_ ci-dessous ou [cliquer ici](/slides/wrangling.qmd)\npour afficher les slides en plein √©cran.\n</summary>\n\n\n``` {.yaml code-preview=\"/slides/wrangling.qmd\"}\n```\n\n</details>\n\n\nDans ce deuxi√®me TP,\nnous allons apprendre √† importer et\nmanipuler des donn√©es avec\n{{< fa brands r-project >}}. \n\nSi vous √™tes int√©ress√©s par `Python` {{< fa brands python >}},\nune version tr√®s proche de ce TP est disponible dans [mon cours de l'ENSAE](https://pythonds.linogaliana.fr/content/manipulation/02b_pandas_TP.html).\n\n\n::: {.callout-note}\n\nCertains exemples de code pr√©sentent des annotations sur le c√¥t√©,\npassez votre souris dessus pour les afficher, comme ci-dessous\n\n```{r}\n#| echo: true\n#| output: false\n\"une annotation explicative m'accompagne √† droite\" #<1>\n```\n1. Je m'affiche quand on passe la souris sur moi üê≠ !\n\n:::\n\nDans ce chapitre, nous allons principalement utiliser les packages suivants\ndu `tidyverse`: \n\n- `readr` pour l'import de donn√©es ;\n- `dplyr` pour la manipulation de donn√©es.\n\n::: {.callout-note}\n\nLe `tidyverse` n'est pas le seul √©cosyst√®me complet pour analyser des donn√©es.\n\nN√©anmoins, pour une introduction √† {{< fa brands r-project >}}, c'est \ncertainement le plus raisonnable √† adopter. \n\nLes √©cosyst√®mes\nconcurrents ou compl√©mentaires (`data.table`, `arrow`, `duckdb`) n√©cessitent\nd√©j√† une bonne compr√©hension du `tidyverse` et de ses limites. \n\n:::\n\nDans ce tutoriel, nous allons utiliser deux sources de donn√©es :\n\n* Les √©missions de gaz √† effet de serre estim√©es au niveau communal par l'`ADEME`. Le jeu de donn√©es est\ndisponible sur [data.gouv](https://www.data.gouv.fr/fr/datasets/inventaire-de-gaz-a-effet-de-serre-territorialise/#_)\net requ√™table directement dans {{< fa brands r-project >}} avec\n[cet url](https://koumoul.com/s/data-fair/api/v1/datasets/igt-pouvoir-de-rechauffement-global/convert) (ce sera l'objet du premier exercice)[^notedownload].\n* Id√©alement, on utiliserait directement les donn√©es\n[disponibles sur le site de l'Insee](https://www.insee.fr/fr/statistiques/3560121) mais celles-ci n√©cessitent un peu de travail\nde nettoyage qui n'entre pas dans le cadre de ce TP. \nPour faciliter l'import de donn√©es Insee, il est recommand√© d'utiliser les _packages_\n[`doremifasol`](https://github.com/InseeFrLab/DoReMIFaSol) et [`insee`](https://github.com/pyr-opendatafr/R-Insee-Data) qui simplifient l'acc√®s aux donn√©es\nde l'Insee disponibles sur le site web [insee.fr](https://www.insee.fr/fr/accueil)\nou via des API. \n\n[^notedownload]: \n\n  `readr` offre la possibilit√© d'importer des donn√©es directement depuis un url. C'est l'option \n  prise dans ce tutoriel. Si vous pr√©f√®rez, pour des \n  raisons d'acc√®s au r√©seau ou de performance, importer depuis un poste local,\n  vous pouvez t√©l√©charger les donn√©es et changer\n  les commandes d'import avec le chemin ad√©quat plut√¥t que l'url. \n\n\n\n{{< fa brands r-project >}} est un langage _open source_. N'importe qui peut\ndonc proposer du code {{< fa brands r-project >}} pour accro√Ætre les \nfonctionnalit√©s du langage. Un ensemble coh√©rent de fonctionnalit√©s s'appelle\nune __librairie__ ou un __package__. \n\nComme l'√©quipe qui g√®re le langage {{< fa brands r-project >}} n'a pas vocation\n√† int√©grer toutes les librairies dans le langage de base (celui-ci se doit\nde rester, comme son nom l'indique, basique), il existe des espaces\ncommunautaires o√π les gens peuvent mettre √† disposition leurs _packages_. Dans\nl'√©cosyst√®me {{< fa brands r-project >}}, les deux principaux[^bioconductor] sont:\n\n- Le `CRAN` (_Comprehensive R Archive Network_): le d√©p√¥t officiel et historique\nde librairies {{< fa brands r-project >}}.\nPour installer un _package_ stock√© dans cet espace, on utilise `install.package` ;\n- `Github` {{< fa brands github >}}: le r√©seau social du code _open source_. \nPour installer un _package_ stock√© dans cet espace, on utilise `remotes::install_github`[^remotes]\n\n[^bioconductor]: Il existe √©galement `bioconductor` mais celui-ci √©tant surtout orient√© biostatistiques (une des communaut√©s acad√©miques ayant adopt√© {{< fa brands r-project >}} le plus t√¥t), nous ne l'utilisons pas vraiment\n\n[^remotes]:\n    `remotes::install_github` signifie d'utiliser la fonction `install_github` du _package_ `remotes`. Autrement dit, il faut un _package_ pour installer d'autres _packages_ ü§Ø.\n    C'est parce que `Github` n'existait pas lors de la cr√©ation de {{< fa brands r-project >}} (ann√©es 1990) et que cette fonctionnalit√© n'a pas √©t√© ajout√© depuis. \n\n::: {.callout-note}\n\nEn g√©n√©ral, les _packages_ avec une certaine\nmaturit√© sont sur le CRAN. `Github` a un aspect plus fourre-tout o√π on trouve\ndes mines d'or √† c√¥t√© de choses de qualit√© plus variable. \n\nCertains _packages_ que nous verrons ne sont pas sur le CRAN car la proc√©dure\nde validation pour pouvoir y d√©poser son _package_ est assez lourde et\nfatiguante pour des d√©veloppeurs b√©n√©voles, g√©n√©ralement non r√©mun√©r√© \npour ce travail et qui effectuent souvent cela la nuit. \n\n:::\n\nPour installer un package disponible sur le CRAN, par exemple\nle package [`dplyr`](https://dplyr.tidyverse.org/),\nvous pouvez faire:\n\n```{r}\n#| eval: false\n#| echo: true\ninstall.packages(\"insee\")\n```\n\nPour installer un package disponible sur `Github` {{< fa brands github >}},\npar exemple [`doremifasol`](https://github.com/InseeFrLab/DoReMIFaSol)\nqui est disponible sur le d√©p√¥t du compte `InseeFrLab`, on fait:\n\n\n```{r}\n#| eval: false\n#| echo: true\nremotes::install_github('inseefrlab/DoReMIFaSol')\n```\n\n\nVoici l'ensemble des instructions pour installer\nles _packages_ afin d'√™tre en mesure d'effectuer tous\nles exercices de ce tutoriel:\n\n```{r}\n#| echo: true\n#| eval: false\ninstall.packages(c(\"readr\",\"dplyr\", \"tidyr\", \"ggplot2\", \"remotes\"))\nremotes::install_github('inseefrlab/DoReMIFaSol')\n```\n\nPuisque nous allons fr√©quemment utiliser `dplyr`, nous pouvons l'importer\ndirectement:\n\n```{r}\n#| echo: true\n#| output: false\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(stringr)\n```\n\n# Importer les donn√©es\n\n## Import d'un csv de l'Ademe\n\nPour commencer, nous allons importer les donn√©es de l'Ademe √† l'aide du\n_package_ [`readr`](https://readr.tidyverse.org/)[^readcsv]. \n\n::: {.callout-tip}\n## Exercice 1: lire un csv avec `readr` et observer les donn√©es\n\nVoici l'URL sur lequel les donn√©es sont disponibles\n\n```{r}\n#| echo: true\nurl <- \"https://koumoul.com/s/data-fair/api/v1/datasets/igt-pouvoir-de-rechauffement-global/convert\"\n```\n\n\n1. Utiliser le _package_  `readr` pour importer ces donn√©es. Nommer cet objet `emissions`[^nomdf]\n2. Afficher les premi√®res lignes avec `head` et observer la diff√©rence d'affichage avec, par exemple,\nce `dataframe`:\n\n```{r}\n#| echo: true\nlibrary(readr)\nemissions <- read_csv(url)\n```\n\n3. Afficher la classe de `emissions`. Comprenez-vous maintenant pourquoi cet objet est un\npeu diff√©rent d'un dataframe de base ?\n4. Utiliser les fonctions ad√©quates pour les 10 premi√®res valeurs, les 15 derni√®res et un √©chantillon al√©atoire de 10 valeurs gr√¢ce √† la [fonction ad√©quate du package `dplyr`](https://dplyr.tidyverse.org/reference/sample_n.html)\n\n<details>\n<summary>\nEn cas de blocage √† la question 1\n</summary>\nLire la documentation de `read_csv` (tr√®s bien faite) ou chercher des exemples\nen ligne pour d√©couvrir cette fonction.\n‚ö†Ô∏è Ne pas utiliser `read.csv` (fonction de base) qui n'est pas performante. \n</details>\n:::\n\n[^nomdf]: Par manque d'imagination, on est souvent tent√© d'appeler notre\n_dataframe_ principal `df` ou `data`. C'est souvent une mauvaise id√©e puisque\nce nom n'est pas tr√®s informatif quand on relit le code quelques semaines\nplus tard. L'autodocumentation, approche qui consiste √† avoir un code\nqui se comprend de lui-m√™me, est une bonne pratique et il est donc recommand√©\nde donner un nom simple mais efficace pour conna√Ætre la nature du _dataset_ en question.\n\n## Premi√®res manipulations de donn√©es\n\nComme c'est √©voqu√©\ndans [`utilitR`](https://www.book.utilitr.org/03_fiches_thematiques/fiche_tidyverse),\nles principales fonctions de `dplyr` (les _verbes_ de la grammaire `dplyr`) \nsont les suivants:\n\n- `select()` : s√©lectionner des variables par leur nom ;\n- `rename()` : renommer des variables ;\n- `filter()` : s√©lectionner des observations selon une ou plusieurs conditions ;\n- `arrange()` : trier la table selon une ou plusieurs variables ;\n- `mutate()` : ajouter des variables qui sont fonction d‚Äôautres variables ;\n- `summarise()` : calculer une statistique √† partir de donn√©es ;\n- `group_by()` : faire des op√©rations par groupe.\n\n```{ojs}\n//| echo: false\nviewof dplyrVerbs = Inputs.select(['select','rename','filter','mutate', 'arrange'], {value: \"select\"})\n```\n\n::: {#fig-verbs}\n\n```{ojs}\n//| echo: false\nhtml`<img src=\"https://github.com/linogaliana/r-geographie/raw/main/exercises/img/${dplyrVerbs}.png\" width=\"60%\"</>`\n```\n\nIllustration des verbes `dplyr`\n\n:::\n\nLa _cheatsheet_ suivante est tr√®s pratique puisqu'elle illustre ces diff√©rentes\nfonctions. Il est recommand√© de r√©guli√®rement\nla consulter (cliquer sur l'image pour zoomer üîé) :\n\n::: {#cheatsheets-dplyr layout-ncol=2}\n\n![](img/cheatsheet1.png)\n\n![](img/cheatsheet2.png)\n\n[_Cheatsheets_ `dplyr`](https://dplyr.tidyverse.org/)\n:::\n\n\n::: {.callout-tip}\n## Exercice 2: d√©couverte des verbes de `dplyr` pour manipuler des donn√©es\n\nEn premier lieu, on propose de se familiariser avec les op√©rations sur\nles colonnes.\n\n1. Cr√©er un _dataframe_ `emissions_copy` ne conservant que les colonnes\n`INSEE commune`, `Commune`, `Autres transports` et `Autres transports international`\n\n<details>\n<summary>\nIndice pour cette question\n</summary>\n![](https://github.com/linogaliana/r-geographie/raw/main/exercises/img/select.png)\n</details>\n\n2. Comme les noms de variables sont peu pratiques, les renommer de la\nmani√®re suivante:\n    + `INSEE commune` $\\to$ `code_insee`\n    + `Autres transports` $\\to$ `transports`\n    + `Autres transports international` $\\to$ `transports_international`\n\n<details>\n<summary>\nIndice pour cette question\n</summary>\n![](https://github.com/linogaliana/r-geographie/raw/main/exercises/img/rename.png)\n</details>\n\n3. On propose, pour simplifier, de remplacer les valeurs manquantes (`NA`)\npar la valeur 0[^na]. Utiliser la\nfonction [`replace_na`](https://tidyr.tidyverse.org/reference/replace_na.html)\ndu package _tidyr_, en conjonction avec `mutate`,\npour transformer les valeurs manquantes en 0.\n\n<details>\n<summary>\nIndice pour cette question\n</summary>\n![](https://github.com/linogaliana/r-geographie/raw/main/exercises/img/mutate.png)\n</details>\n\n\n4. Cr√©er dans la m√™me s√©quence de code les variables suivantes:\n    - `dep`: le d√©partement. Celui-ci peut √™tre cr√©√© gr√¢ce aux deux premiers caract√®res de `code_insee` avec la fonction `str_sub` du _package_ `stringr`[^notecorse]\n    - `transports_total`: les √©missions du secteur transports (somme des deux variables)\n\n<details>\n<summary>\nIndice pour cette question\n</summary>\n![](https://github.com/linogaliana/r-geographie/raw/main/exercises/img/mutate.png)\n</details>\n\n\n5. Ordonner les donn√©es du plus gros pollueur au plus petit \npuis ordonner les donn√©es \ndu plus gros pollueur au plus petit par d√©partement (du 01 au 95). \n\n<details>\n<summary>\nIndice pour cette question\n</summary>\n![](https://github.com/linogaliana/r-geographie/raw/main/exercises/img/arrange.png)\n</details>\n\n6. Calculer les √©missions totales par d√©partements\n\n<details>\n<summary>\nIndice pour cette question\n</summary>\n\n* _\"Grouper par\"_ = `group_by`\n* _\"√©missions totales\"_ = `summarise(sum(***))`\n\n</details>\n\n\n:::\n\n[^na]: Cette hypoth√®se est certainement fausse. Elle est exclusivement\nl√† pour illustrer la cr√©ation de variables via `mutate`.\n\n[^notecorse]: Pour √™tre vraiment pr√©cis, il faudrait modifier les valeurs\nobtenues pour les d√©partements Corse avec la fonction `case_when`\ndu _package_ `dplyr`. Ceci est laiss√© en exercice suppl√©mentaire. \n\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 1\"\nemissions_copy <- emissions %>%\n  select(`INSEE commune`, `Commune`, `Autres transports`, `Autres transports international`)\n```\n  \n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 2\"\nemissions_copy <- emissions_copy %>%\n  rename(\n    code_insee = `INSEE commune`,\n    transports = `Autres transports`,\n    transports_international = `Autres transports international`\n    )\n```\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 3\"\nemissions_copy <- emissions_copy %>%\n  mutate(\n    transports = replace_na(transports),\n    transports_international = replace_na(transports_international)\n    )\n```\n\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 4\"\nemissions_copy <- emissions_copy %>%\n  mutate(\n    dep = str_sub(code_insee, 1, 2),\n    transports_total = transports + transports_international\n    )\n```\n\n```{r}\n#| output: false\n#| code-fold: true\n#| code-summary: \"Solution question 5\"\nemissions_copy %>%\n  arrange(desc(transports_total))\n\nemissions_copy %>%\n  arrange(dep, desc(transports_total))\n```\n\n```{r}\n#| output: false\n#| code-fold: true\n#| code-summary: \"Solution question 6\"\nemissions_copy %>%\n  group_by(dep) %>%\n  summarise(sum(transports_total))\n\n```\n\n## Import de donn√©es de l'Insee\n\nEn ce qui concerne nos informations communales, on va utiliser l'une des plus\nsources de l'Insee les plus utilis√©es : les donn√©es [`Filosofi`](https://www.insee.fr/fr/metadonnees/source/serie/s1172). \nAfin de faciliter la r√©cup√©ration de celles-ci, nous allons\nutiliser le _package_ communautaire `doremifasol` :\n\n```{r}\n#| output: false\n#| echo: true\nlibrary(doremifasol)\nlibrary(tibble)\nfilosofi <- as_tibble(\n  telechargerDonnees(\"FILOSOFI_COM\", date = 2016)\n)\nhead(filosofi)\n```\n\n```{r}\n#| echo: false\nhead(filosofi)\n```\n\n::: {.callout-note}\nLa fonction `as_tibble` nous sert √† transformer le _dataframe_ de base (`doremifasol` \nne fait pas d'_a priori_ sur l'√©cosyst√®me de manipulation adopt√©) en \n_dataframe_ adapt√© √† une exploitation via le `tidyverse`. \n:::\n\n# Nettoyage des donn√©es\n\n:::{.callout-tip}\n## Exercice 2\n\nComme c'est `readr` ou `doremifasol` qui ont\ng√©r√© automatiquement l'import des donn√©es, on va faire un petit\ncontr√¥le qualit√©:\n\n1. Afficher le nom des colonnes de nos _dataframes_ `emissions` et `filosofi`. \nQuelles sont les colonnes communes ? Utiliser la fonction `intersect` et comprendre\nla nature du probl√®me.\n2. Observer la structure de nos jeux de donn√©es (les types des colonnes). Les types fix√©s par d√©faut sont-ils ad√©quats ?\n\nEnsuite, on v√©rifie les dimensions des `DataFrames` et la structure de certaines variables cl√©s.\nEn l'occurrence, les variables fondamentales pour lier nos donn√©es sont les variables communales.\nIci, on a deux variables g√©ographiques: un code commune et un nom de commune. \nOn va donc v√©rifier qu'elles sont bien adapt√©es √† l'analyse statistique.\n\n3. V√©rifier les dimensions des _dataframes_ ;\n4. V√©rifier le nombre de valeurs uniques des variables g√©ographiques dans chaque base. Les r√©sultats apparaissent-ils coh√©rents ?\n5. Identifier dans `filosofi` les noms de communes qui correspondent √† plusieurs codes communes et s√©lectionner leurs codes. En d'autres termes, identifier les `CODGEO` tels qu'il existe des doublons de `LIBGEO` et les stocker dans un dataframe `duplicates`\n\nOn se focalise temporairement sur les observations o√π le libell√© comporte plus de deux codes communes diff√©rents\n\n6. Regarder dans `filosofi` ces observations. Pour mieux y voir, r√©ordonner la base obtenue par order alphab√©tique\n7. D√©terminer la taille moyenne (variable nombre de personnes: `NBPERSMENFISC16`) et quelques statistiques descriptives de ces donn√©es.\nComparer aux m√™mes statistiques sur les donn√©es o√π libell√©s et codes communes co√Øncident\n8. V√©rifier les grandes villes (plus de 100 000 personnes),\nla proportion de villes pour lesquelles un m√™me nom est associ√© √† diff√©rents codes commune.\n9. V√©rifier dans `filosofi` les villes dont le libell√© est √©gal √† Montreuil.\nV√©rifier √©galement celles qui contiennent le terme 'Saint-Denis'\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 1\"\n#| output: false\nstr(emissions)\nintersect(colnames(filosofi), colnames(emissions))\n```\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 2\"\n#| output: false\nstr(filosofi)\nstr(emissions)\n```\n\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 3\"\n#| output: false\ndim(filosofi)\ndim(emissions)\n```\n\n```{r}\n#| output: false\n#| code-fold: true\n#| code-summary: \"Solution question 3\"\n\nemissions %>%\n  select('INSEE commune', 'Commune') %>%\n  summarize(Unique_Count = n_distinct(Commune))\n\nfilosofi %>%\n  select('CODGEO', 'LIBGEO') %>%\n  summarize(Unique_Count = n_distinct(LIBGEO))\n```\n\n```{r}\n#| output: false\n#| code-fold: true\n#| code-summary: \"Solution questions 5 √† 7\"\n\n# Question 5\nduplicates <- filosofi %>%\n  group_by(LIBGEO) %>%\n  summarize(Count = n()) %>%\n  select(LIBGEO, Count) %>%\n  #arrange(desc(Count)) %>%\n  filter(Count > 1)\n\n# Question 6\nfilosofi %>%\n  filter(LIBGEO %in% duplicates$LIBGEO) %>%\n  arrange(LIBGEO)\n\n# Question 7\nfilosofi %>%\n  filter(LIBGEO %in% duplicates$LIBGEO) %>%\n  summarize(Stats = mean(NBPERSMENFISC16, na.rm = TRUE))\n\n# Calculate summary statistics for 'NBPERSMENFISC16' for rows where 'LIBGEO' is not in 'x$LIBGEO'\nfilosofi %>%\n  filter(!(LIBGEO %in% duplicates$LIBGEO)) %>%\n  summarize(Stats = mean(NBPERSMENFISC16, na.rm = TRUE))\n```\n\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 8\"\n\nfilosofi_big <- filosofi %>%\n  filter(NBPERSMENFISC16 > 100000) %>%\n  mutate(probleme = LIBGEO %in% duplicates$LIBGEO)\n\n# Proportion de villes √† probl√®me\nmean_probleme <- filosofi_big %>%\n  summarize(mean(probleme))\n\n# Filter rows where 'probleme' is TRUE\ndf_probleme <- filosofi_big %>%\n  filter(probleme)\n```\n\n<details>\n<summary>\nCe que vous devriez trouver dans les questions 8 et 9\n</summary>\n\nPour la question 8, vous devriez obtenir ceci:\n\n\n```{r}\nhead(df_probleme)\n```\n\nAlors que pour la question 9, vos deux _dataframes_ ressembleront √†\n\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 9\"\n# Question 9\nfilosofi %>%\n  filter(LIBGEO == 'Montreuil')\n\n# Question 10\nfilosofi %>%\n  filter(grepl('Saint-Denis', LIBGEO)) %>%\n  head(10)\n```\n</details>\n\n:::\n\nCe petit exercice permet de se rassurer car les libell√©s dupliqu√©s\nsont en fait des noms de commune identiques mais qui ne sont pas dans le m√™me d√©partement.\nIl ne s'agit donc pas d'observations dupliqu√©es.\nOn se fiera ainsi aux codes communes, qui eux sont uniques.\n\n\n::: {.callout-tip}\n## Exercice 3\n\nOn va commencer l'exploration de donn√©es. Cela implique un peu de\nnettoyage de donn√©es en amont. \n\n1. Renommer la variable `INSEE commune` en `code_insee`[^espace]. \n2. Les deux premiers chiffres des codes communes sont le num√©ro de d√©partement.\nCr√©er une variable de d√©partement `dep` dans `emissions` et dans `filosofi`\nen utilisant la fonction `str_sub` du package `stringr`[^stringr].\n\nCommen√ßons le calcul de nos premi√®res statistiques descriptives. \n\n3. Calculer les √©missions totales par secteur pour chaque d√©partement.\nMettre en _log_ ces r√©sultats dans un objet `emissions_log`.\nLa @fig-sample-log illustre la structure de ces √©missions sur 5 d√©partements\nal√©atoires. \n\n4. Repartir du jeu de donn√©es `emissions`.\nCalculer les √©missions totales par d√©partement et sortir la liste\ndes 10 principaux √©metteurs de CO2 et des 5 d√©partements les moins √©metteurs.\nSans faire de *merge*,\nregarder les caract√©ristiques de ces d√©partements (population et niveau de vie)\n\n[^stringr]: Les fonctionnalit√©s limit√©es du langage de base sur la manipulation\ntextuelle sont rapidement contraignantes. On passe ainsi rapidement √† `stringr`\nm√™me si ce n'est pas l'objet principal du chapitre. \n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 1\"\n#| output: false\nlibrary(stringr)\n\nemissions <- emissions %>%\n  rename('code_insee' = `INSEE commune`)\n```\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 2\"\nemissions <- emissions %>%\n  mutate(dep = str_sub(code_insee, start = 1, end = 2))\nfilosofi <- filosofi %>%\n  mutate(dep = str_sub(CODGEO, start = 1, end = 2))\n```\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 3\"\n#| label: question 3 exo 3\n#| output: false\nemissions_log <- emissions %>%\n    group_by(dep) %>%\n    summarise(across(where(is.numeric), sum, na.rm = TRUE)) %>%\n    mutate(across(where(is.numeric), log))\n```\n\n```{r}\n#| output: false\n#| code-fold: true\n#| code-summary: \"Solution question 4\"\n\n## Emissions totales par d√©partement\nemissions_dep <- emissions %>%\n  mutate(total = rowSums(pick(where(is.numeric)), na.rm = TRUE)) %>%\n  group_by(dep) %>%\n  summarise(total = sum(total))\ngros_emetteurs <- emissions_dep %>%\n  arrange(desc(total)) %>%\n  head(10)\npetits_emetteurs <- emissions_dep %>%\n  arrange(total) %>%\n  head(5)\n\n## Caract√©ristiques de ces d√©partements dans filosofi\ngros_emetteurs_filosofi <- filosofi %>%\n  filter(dep %in% gros_emetteurs$dep) %>%\n  group_by(dep) %>%\n  summarise(across(c('NBPERSMENFISC16','MED16'), \\(x) mean(x, na.rm = TRUE)))\n\nhead(gros_emetteurs_filosofi)\n```\n\n\n```{r}\n#| echo: true\n#| fig-cap: Structure des √©missions de cinq d√©partements al√©atoires\n#| label: fig-sample-log\n#| code-fold: true\n#| code-summary: \"Code pour cr√©er la figure ci-dessous\"\n\nlibrary(tidyr)\nlibrary(ggplot2)\n\nemissions_log_sample <- emissions_log %>%\n  filter(dep %in% sample(unique(dep),5))\n\nemissions_log_sample <- emissions_log_sample %>%\n  pivot_longer(cols = -dep, names_to = \"Category\", values_to = \"Value\")\n\nggplot(emissions_log_sample, aes(x = dep, y = Value, fill = Category)) +\n    geom_bar(stat = \"identity\") +\n    labs(x = \"Department\", y = \"Value\") +\n    theme_minimal() +\n    theme(axis.text.x = element_text(angle = 45, hjust = 1)) + scale_fill_viridis_d()\n```\n\n\n<details>\n<summary>\nExemple d'utilisation de `str_sub`\n</summary>\n```r\nlibrary(stringr)\ndf %>% mutate(x = str_sub(y, start = 3, end = 5))\n```\n\n</details>\n\n:::\n\n[^espace]: L'espace dans le nom de la variable est emb√™tant. Pour pouvoir\nutiliser le nom de cet variable dans `rename`, il va falloir utiliser\ndes backticks, c'est-√†-dire ` INSEE commune `.\n\n\n# Restructurer des donn√©es\n\nOn pr√©sente g√©n√©ralement deux types de donn√©es : \n    \n* format __wide__: les donn√©es comportent des observations r√©p√©t√©es, pour un m√™me individu (ou groupe), dans des colonnes diff√©rentes \n* format __long__: les donn√©es comportent des observations r√©p√©t√©es, pour un m√™me individu, dans des lignes diff√©rentes avec une colonne permettant de distinguer les niveaux d'observations\n\nUn exemple de la distinction entre les deux peut √™tre pris √† l'ouvrage de r√©f√©rence d'Hadley Wickham, *R for Data Science*:\n\n![Donn√©es _long_ (gauche) et _wide_ (droite) (source: *R for Data Science*)](https://d33wubrfki0l68.cloudfront.net/3aea19108d39606bbe49981acda07696c0c7fcd8/2de65/images/tidy-9.png)\n\nOn est souvent amen√© avec {{< fa brands r-project >}} √† restructurer les donn√©es\npour les allonger (_wide to long_) et les √©largir (_long to wide_). \nC'est le package _tidyr_ (qui appartient au _tidyverse_) qui permet\nde faire ce type de transformations.\n\nL'aide m√©moire suivante aidera √† se rappeler les fonctions √† appliquer si besoin:\n\n![](https://scienceparkstudygroup.github.io/r-lesson-based-on-ohi-data-training/img/rstudio-cheatsheet-spread-gather-sep-unite.png){width=\"80%\" fig-align=\"center\"}\n\nLe fait de passer d'un format *wide* au format *long* (ou vice-versa)\npeut √™tre extr√™mement pratique car certaines fonctions sont plus ad√©quates sur une forme de donn√©es ou sur l'autre.\n\nEn r√®gle g√©n√©rale, les formats *long* sont souvent pr√©f√©rables car il est\nplus facile d'it√©rer sur des lignes que sur des colonnes du fait de\nla nature vectorielle de {{< fa brands r-project >}}.\nC'est notamment\nla forme de donn√©es privil√©gi√©e pour pr√©parer des graphiques avec `ggplot`, \nque nous d√©couvrirons dans le prochain chapitre. \n\n\n:::{.callout-tip}\n## Exercice 4: la transformation _wide to long_\n1. Restructurer les donn√©es au format *long* pour avoir des donn√©es d'√©missions par secteur en gardant comme niveau d'analyse la commune (attention aux autres variables identifiantes).\n2. Faire la somme par secteur et repr√©senter graphiquement un _barplot_[^barplot] \n3. Garder, pour chaque d√©partement, le secteur le plus polluant\n\n[^barplot]: vous pouvez\nutiliser directement le morceau de code d'aide si vous n'√™tes pas familiers de `ggplot`\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 1\"\n\nlibrary(tidyr)\n\ndf_long <- emissions %>%\n  pivot_longer(cols = -c(code_insee, Commune, dep),\n               names_to = \"secteur\",\n               values_to = \"emissions\")\n```\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 2\"\n\ndf_long_summary <- df_long %>%\n  group_by(secteur) %>% summarise(emissions = sum(emissions, na.rm = TRUE))\n```\n\n<details>\n<summary>Graphique √† r√©aliser pour la question 2</summary>\n\nUne fois le _dataframe_ `df_long_summary` cr√©√©, le code minimal\npour r√©aliser le _barplot_ voulu est:\n\n```{r}\n#| echo: true\nggplot(df_long_summary) +\n  geom_bar(\n    aes(y = secteur, x = emissions),\n    stat ='identity'\n  )\n```\n\nPas besoin d'aller plus loin pour le moment, nous ferons plus\nde `ggplot` ult√©rieurement. \n\n</details>\n\n```{r}\n#| output: false\n#| code-fold: true\n#| code-summary: \"Solution question 3\"\ndf_long_dep <- df_long %>%\n  group_by(secteur, dep) %>%\n  summarise(emissions = sum(emissions, na.rm = TRUE)) %>%\n  arrange(desc(dep), desc(emissions)) %>%\n  group_by(dep) %>%\n  slice_head(n = 1)\n```\n\n```{r}\n#| echo: false\nhead(df_long_dep)\n```\n\n\n:::\n\n\n::: {.callout-tip}\n## Exercice 5: _long to wide_\n\nTO DO\n:::\n\n\n# Combiner les donn√©es\n\nUne information que l'on cherche √† obtenir s'obtient de moins en moins √† partir d'une unique base de donn√©es. Il devient commun de devoir combiner des donn√©es issues de sources diff√©rentes. \n\nNous allons ici nous focaliser sur le cas le plus favorable qui est la situation o√π une information permet d'apparier de mani√®re exacte deux bases de donn√©es (autrement nous serions dans une situation, beaucoup plus complexe, d'appariement flou). La situation typique est l'appariement entre deux sources de donn√©es selon un identifiant individuel ou un identifiant de code commune, ce qui est notre cas.\n\nIl est recommand√© de lire [ce guide assez complet sur la question des jointures avec {{< fa brands r-project >}}](https://www.book.utilitr.org/03_fiches_thematiques/fiche_joindre_donnees) qui donne des recommandations √©galement utiles en `Python` {{< fa brands python >}}.\n\nDans le langage courant du statisticien,\non utilise de mani√®re indiff√©rente les termes *merge* ou *join*. Le deuxi√®me terme provient de la syntaxe `SQL` et c'est celui qui est plut√¥t utilis√©\nquand on code avec `dplyr`. \n\n<details>\n\n<summary>\nLes diff√©rents type de _join_ disponibles dans `dplyr`\n</summary>\n\n![](https://rafalab.dfci.harvard.edu/dsbook/wrangling/img/joins.png){width=80%}\n\n</details>\n\n::: {.callout-tip}\n## Exercice 6: enrichir les donn√©es d'√©missions\n\nEn premier lieu, on va calculer l'empreinte carbone de chaque commune. \n\n1. Calculer les √©missions totales en utilisant la commande suivante\n(comme celle-ci est complexe, nous la donnons directement):\n\n```r\nemissions <- emissions %>%\n  mutate(total = rowSums(pick(where(is.numeric)), na.rm = TRUE))\n```\n\n\n2. Faire une jointure √† gauche entre les donn√©es d'√©missions et les donn√©es de cadrage[^notebiais].\n\n[^notebiais]: Id√©alement, il serait n√©cessaire de s'assurer que cette jointure n'introduit\npas de biais. En effet, comme nos ann√©es de r√©f√©rence ne sont pas forc√©ment identiques,\nil peut y avoir un _mismatch_ entre nos deux sources. Le TP √©tant d√©j√† long, nous n'allons pas dans cette voie. Les lecteurs int√©ress√©s pourront effectuer une telle analyse en exercice suppl√©mentaire.\n\n3. Calculer l'empreinte carbone (√©missions totales / population).\n\nA ce stade nous pourrions avoir envie d'aller vers la mod√©lisation pour essayer d'expliquer\nles d√©terminants de l'empreinte carbone √† partir de variables communales. \nUne approche inf√©rentielle n√©cessite n√©anmoins pour √™tre pertinente de\nv√©rifier en amont des statistiques descriptives.\n\n4. Utiliser le code suivant pour sortir un histogramme en niveau puis en log de l'empreinte carbone communale ;\n\n```r\nggplot(emissions_merged) +\n  geom_histogram(aes(x = empreinte, y = after_stat(density))) +\n  scale_x_log10()\n```\n\n5. Pour chaque ville, comparer l'empreinte carbone √† la m√©diane du d√©partement. En relatif, quelles sont les villes particuli√®rement vertueuses (c'est-√†-dire celles qui ont des √©missions bien inf√©rieures √† la moyenne d√©partementale) ?\n\nAvec une meilleure compr√©hension de nos donn√©es, nous nous rapprochons\nde la statistique inf√©rentielle. N√©anmoins, nous avons jusqu'√† pr√©sent\nconstruit des statistiques univari√©es mais n'avons pas cherch√© √† comprendre\nles r√©sultats en regardant le lien avec d'autres variables. \nCela nous am√®ne vers la statistique bivari√©e, notamment l'analyse des corr√©lations. \nCe travail est important puisque toute mod√©lisation ult√©rieure consistera √† \nraffiner l'analyse des corr√©lations pour tenir compte des corr√©lations crois√©es\nentre multiples facteurs. On propose ici de faire cette analyse\nde mani√®re minimale. \n\n6. Regarder la corr√©lation entre les variables de cadrage et l'empreinte carbone (la solution est donn√©e, car les manipulations ne sont pas √©videntes).\nCertaines variables semblent-elles pouvoir potentiellement influer sur l'empreinte carbone ?\n\n```{r}\n#| output: false\n#| code-fold: true\n#| code-summary: \"Solution question 1\"\n\nemissions <- emissions %>%\n  mutate(total = rowSums(pick(where(is.numeric)), na.rm = TRUE))\n```\n\n```{r}\n#| output: false\n#| code-fold: true\n#| code-summary: \"Solution question 2\"\nemissions_merged <- emissions %>%\n  left_join(filosofi, by = c(\"code_insee\" = \"CODGEO\"))\n```\n\n```{r}\n#| output: false\n#| code-fold: true\n#| code-summary: \"Solution question 3\"\nemissions_merged <- emissions_merged %>%\n  mutate(empreinte = total/NBPERSMENFISC16)\n```\n\n```{r}\n#| output: false\n#| code-fold: true\n#| code-summary: \"Solution question 4\"\nggplot(emissions_merged) +\n  geom_histogram(aes(x = empreinte, y = after_stat(density))) +\n  scale_x_log10()\n```\n\n```{r}\n#| output: false\n#| code-fold: true\n#| code-summary: \"Solution question 5\"\n#| echo: true\nemissions_merged <- emissions_merged %>%\n  rename(departement = dep.x) %>%\n  group_by(departement) %>%\n  mutate(empreinte_mediane = median(empreinte, na.rm = TRUE)) %>%\n  mutate(empreinte_relative = empreinte/empreinte_mediane)\n\nemissions_merged %>% arrange(empreinte_relative)\n```\n\n\n\n```{r}\n#| output: false\n#| code-fold: true\n#| code-summary: \"Solution question 6\"\n\nlibrary(tibble)\n\ncorrelations <- cor(\n  emissions_merged %>% ungroup() %>% select(where(is.numeric)),\n  use=\"complete.obs\"\n  )[,'empreinte']\n\ncorrelations <- enframe(correlations) %>%\n  filter(name %in% colnames(filosofi)) %>%\n  arrange(desc(abs(value)))\n```\n\nVoici une visualisation rapide des corr√©lations √† l'empreinte carbone:\n\n```{r}\nggplot(correlations) + geom_bar(aes(x = value, y = name), stat = \"identity\") +\n  scale_y_discrete(limits = correlations$name) \n```\n\n:::\n\n\n","srcMarkdownNoYaml":"\n\n::: {.badge}\n<a href=\"https://datalab.sspcloud.fr/launcher/ide/rstudio?autoLaunch=false&networking.user.enabled=true&onyxia.friendlyName=%C2%ABrstudio-cours-ENS%C2%BB\" target=\"_blank\" rel=\"noopener\"><img src=\"https://img.shields.io/badge/Tester%20via%20SSP%20cloud%20-%20SSPCloud?logo=R&labelColor=black&color=%231965b8\" alt=\"Onyxia\"></a><br>\n:::\n\n<details>\n<summary>\nD√©rouler les _slides_ ci-dessous ou [cliquer ici](/slides/wrangling.qmd)\npour afficher les slides en plein √©cran.\n</summary>\n\n\n``` {.yaml code-preview=\"/slides/wrangling.qmd\"}\n```\n\n</details>\n\n\nDans ce deuxi√®me TP,\nnous allons apprendre √† importer et\nmanipuler des donn√©es avec\n{{< fa brands r-project >}}. \n\nSi vous √™tes int√©ress√©s par `Python` {{< fa brands python >}},\nune version tr√®s proche de ce TP est disponible dans [mon cours de l'ENSAE](https://pythonds.linogaliana.fr/content/manipulation/02b_pandas_TP.html).\n\n\n::: {.callout-note}\n\nCertains exemples de code pr√©sentent des annotations sur le c√¥t√©,\npassez votre souris dessus pour les afficher, comme ci-dessous\n\n```{r}\n#| echo: true\n#| output: false\n\"une annotation explicative m'accompagne √† droite\" #<1>\n```\n1. Je m'affiche quand on passe la souris sur moi üê≠ !\n\n:::\n\nDans ce chapitre, nous allons principalement utiliser les packages suivants\ndu `tidyverse`: \n\n- `readr` pour l'import de donn√©es ;\n- `dplyr` pour la manipulation de donn√©es.\n\n::: {.callout-note}\n\nLe `tidyverse` n'est pas le seul √©cosyst√®me complet pour analyser des donn√©es.\n\nN√©anmoins, pour une introduction √† {{< fa brands r-project >}}, c'est \ncertainement le plus raisonnable √† adopter. \n\nLes √©cosyst√®mes\nconcurrents ou compl√©mentaires (`data.table`, `arrow`, `duckdb`) n√©cessitent\nd√©j√† une bonne compr√©hension du `tidyverse` et de ses limites. \n\n:::\n\nDans ce tutoriel, nous allons utiliser deux sources de donn√©es :\n\n* Les √©missions de gaz √† effet de serre estim√©es au niveau communal par l'`ADEME`. Le jeu de donn√©es est\ndisponible sur [data.gouv](https://www.data.gouv.fr/fr/datasets/inventaire-de-gaz-a-effet-de-serre-territorialise/#_)\net requ√™table directement dans {{< fa brands r-project >}} avec\n[cet url](https://koumoul.com/s/data-fair/api/v1/datasets/igt-pouvoir-de-rechauffement-global/convert) (ce sera l'objet du premier exercice)[^notedownload].\n* Id√©alement, on utiliserait directement les donn√©es\n[disponibles sur le site de l'Insee](https://www.insee.fr/fr/statistiques/3560121) mais celles-ci n√©cessitent un peu de travail\nde nettoyage qui n'entre pas dans le cadre de ce TP. \nPour faciliter l'import de donn√©es Insee, il est recommand√© d'utiliser les _packages_\n[`doremifasol`](https://github.com/InseeFrLab/DoReMIFaSol) et [`insee`](https://github.com/pyr-opendatafr/R-Insee-Data) qui simplifient l'acc√®s aux donn√©es\nde l'Insee disponibles sur le site web [insee.fr](https://www.insee.fr/fr/accueil)\nou via des API. \n\n[^notedownload]: \n\n  `readr` offre la possibilit√© d'importer des donn√©es directement depuis un url. C'est l'option \n  prise dans ce tutoriel. Si vous pr√©f√®rez, pour des \n  raisons d'acc√®s au r√©seau ou de performance, importer depuis un poste local,\n  vous pouvez t√©l√©charger les donn√©es et changer\n  les commandes d'import avec le chemin ad√©quat plut√¥t que l'url. \n\n\n# Etapes pr√©liminaires: installer les _packages_\n\n{{< fa brands r-project >}} est un langage _open source_. N'importe qui peut\ndonc proposer du code {{< fa brands r-project >}} pour accro√Ætre les \nfonctionnalit√©s du langage. Un ensemble coh√©rent de fonctionnalit√©s s'appelle\nune __librairie__ ou un __package__. \n\nComme l'√©quipe qui g√®re le langage {{< fa brands r-project >}} n'a pas vocation\n√† int√©grer toutes les librairies dans le langage de base (celui-ci se doit\nde rester, comme son nom l'indique, basique), il existe des espaces\ncommunautaires o√π les gens peuvent mettre √† disposition leurs _packages_. Dans\nl'√©cosyst√®me {{< fa brands r-project >}}, les deux principaux[^bioconductor] sont:\n\n- Le `CRAN` (_Comprehensive R Archive Network_): le d√©p√¥t officiel et historique\nde librairies {{< fa brands r-project >}}.\nPour installer un _package_ stock√© dans cet espace, on utilise `install.package` ;\n- `Github` {{< fa brands github >}}: le r√©seau social du code _open source_. \nPour installer un _package_ stock√© dans cet espace, on utilise `remotes::install_github`[^remotes]\n\n[^bioconductor]: Il existe √©galement `bioconductor` mais celui-ci √©tant surtout orient√© biostatistiques (une des communaut√©s acad√©miques ayant adopt√© {{< fa brands r-project >}} le plus t√¥t), nous ne l'utilisons pas vraiment\n\n[^remotes]:\n    `remotes::install_github` signifie d'utiliser la fonction `install_github` du _package_ `remotes`. Autrement dit, il faut un _package_ pour installer d'autres _packages_ ü§Ø.\n    C'est parce que `Github` n'existait pas lors de la cr√©ation de {{< fa brands r-project >}} (ann√©es 1990) et que cette fonctionnalit√© n'a pas √©t√© ajout√© depuis. \n\n::: {.callout-note}\n\nEn g√©n√©ral, les _packages_ avec une certaine\nmaturit√© sont sur le CRAN. `Github` a un aspect plus fourre-tout o√π on trouve\ndes mines d'or √† c√¥t√© de choses de qualit√© plus variable. \n\nCertains _packages_ que nous verrons ne sont pas sur le CRAN car la proc√©dure\nde validation pour pouvoir y d√©poser son _package_ est assez lourde et\nfatiguante pour des d√©veloppeurs b√©n√©voles, g√©n√©ralement non r√©mun√©r√© \npour ce travail et qui effectuent souvent cela la nuit. \n\n:::\n\nPour installer un package disponible sur le CRAN, par exemple\nle package [`dplyr`](https://dplyr.tidyverse.org/),\nvous pouvez faire:\n\n```{r}\n#| eval: false\n#| echo: true\ninstall.packages(\"insee\")\n```\n\nPour installer un package disponible sur `Github` {{< fa brands github >}},\npar exemple [`doremifasol`](https://github.com/InseeFrLab/DoReMIFaSol)\nqui est disponible sur le d√©p√¥t du compte `InseeFrLab`, on fait:\n\n\n```{r}\n#| eval: false\n#| echo: true\nremotes::install_github('inseefrlab/DoReMIFaSol')\n```\n\n\nVoici l'ensemble des instructions pour installer\nles _packages_ afin d'√™tre en mesure d'effectuer tous\nles exercices de ce tutoriel:\n\n```{r}\n#| echo: true\n#| eval: false\ninstall.packages(c(\"readr\",\"dplyr\", \"tidyr\", \"ggplot2\", \"remotes\"))\nremotes::install_github('inseefrlab/DoReMIFaSol')\n```\n\nPuisque nous allons fr√©quemment utiliser `dplyr`, nous pouvons l'importer\ndirectement:\n\n```{r}\n#| echo: true\n#| output: false\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(stringr)\n```\n\n# Importer les donn√©es\n\n## Import d'un csv de l'Ademe\n\nPour commencer, nous allons importer les donn√©es de l'Ademe √† l'aide du\n_package_ [`readr`](https://readr.tidyverse.org/)[^readcsv]. \n\n::: {.callout-tip}\n## Exercice 1: lire un csv avec `readr` et observer les donn√©es\n\nVoici l'URL sur lequel les donn√©es sont disponibles\n\n```{r}\n#| echo: true\nurl <- \"https://koumoul.com/s/data-fair/api/v1/datasets/igt-pouvoir-de-rechauffement-global/convert\"\n```\n\n\n1. Utiliser le _package_  `readr` pour importer ces donn√©es. Nommer cet objet `emissions`[^nomdf]\n2. Afficher les premi√®res lignes avec `head` et observer la diff√©rence d'affichage avec, par exemple,\nce `dataframe`:\n\n```{r}\n#| echo: true\nlibrary(readr)\nemissions <- read_csv(url)\n```\n\n3. Afficher la classe de `emissions`. Comprenez-vous maintenant pourquoi cet objet est un\npeu diff√©rent d'un dataframe de base ?\n4. Utiliser les fonctions ad√©quates pour les 10 premi√®res valeurs, les 15 derni√®res et un √©chantillon al√©atoire de 10 valeurs gr√¢ce √† la [fonction ad√©quate du package `dplyr`](https://dplyr.tidyverse.org/reference/sample_n.html)\n\n<details>\n<summary>\nEn cas de blocage √† la question 1\n</summary>\nLire la documentation de `read_csv` (tr√®s bien faite) ou chercher des exemples\nen ligne pour d√©couvrir cette fonction.\n‚ö†Ô∏è Ne pas utiliser `read.csv` (fonction de base) qui n'est pas performante. \n</details>\n:::\n\n[^nomdf]: Par manque d'imagination, on est souvent tent√© d'appeler notre\n_dataframe_ principal `df` ou `data`. C'est souvent une mauvaise id√©e puisque\nce nom n'est pas tr√®s informatif quand on relit le code quelques semaines\nplus tard. L'autodocumentation, approche qui consiste √† avoir un code\nqui se comprend de lui-m√™me, est une bonne pratique et il est donc recommand√©\nde donner un nom simple mais efficace pour conna√Ætre la nature du _dataset_ en question.\n\n## Premi√®res manipulations de donn√©es\n\nComme c'est √©voqu√©\ndans [`utilitR`](https://www.book.utilitr.org/03_fiches_thematiques/fiche_tidyverse),\nles principales fonctions de `dplyr` (les _verbes_ de la grammaire `dplyr`) \nsont les suivants:\n\n- `select()` : s√©lectionner des variables par leur nom ;\n- `rename()` : renommer des variables ;\n- `filter()` : s√©lectionner des observations selon une ou plusieurs conditions ;\n- `arrange()` : trier la table selon une ou plusieurs variables ;\n- `mutate()` : ajouter des variables qui sont fonction d‚Äôautres variables ;\n- `summarise()` : calculer une statistique √† partir de donn√©es ;\n- `group_by()` : faire des op√©rations par groupe.\n\n```{ojs}\n//| echo: false\nviewof dplyrVerbs = Inputs.select(['select','rename','filter','mutate', 'arrange'], {value: \"select\"})\n```\n\n::: {#fig-verbs}\n\n```{ojs}\n//| echo: false\nhtml`<img src=\"https://github.com/linogaliana/r-geographie/raw/main/exercises/img/${dplyrVerbs}.png\" width=\"60%\"</>`\n```\n\nIllustration des verbes `dplyr`\n\n:::\n\nLa _cheatsheet_ suivante est tr√®s pratique puisqu'elle illustre ces diff√©rentes\nfonctions. Il est recommand√© de r√©guli√®rement\nla consulter (cliquer sur l'image pour zoomer üîé) :\n\n::: {#cheatsheets-dplyr layout-ncol=2}\n\n![](img/cheatsheet1.png)\n\n![](img/cheatsheet2.png)\n\n[_Cheatsheets_ `dplyr`](https://dplyr.tidyverse.org/)\n:::\n\n\n::: {.callout-tip}\n## Exercice 2: d√©couverte des verbes de `dplyr` pour manipuler des donn√©es\n\nEn premier lieu, on propose de se familiariser avec les op√©rations sur\nles colonnes.\n\n1. Cr√©er un _dataframe_ `emissions_copy` ne conservant que les colonnes\n`INSEE commune`, `Commune`, `Autres transports` et `Autres transports international`\n\n<details>\n<summary>\nIndice pour cette question\n</summary>\n![](https://github.com/linogaliana/r-geographie/raw/main/exercises/img/select.png)\n</details>\n\n2. Comme les noms de variables sont peu pratiques, les renommer de la\nmani√®re suivante:\n    + `INSEE commune` $\\to$ `code_insee`\n    + `Autres transports` $\\to$ `transports`\n    + `Autres transports international` $\\to$ `transports_international`\n\n<details>\n<summary>\nIndice pour cette question\n</summary>\n![](https://github.com/linogaliana/r-geographie/raw/main/exercises/img/rename.png)\n</details>\n\n3. On propose, pour simplifier, de remplacer les valeurs manquantes (`NA`)\npar la valeur 0[^na]. Utiliser la\nfonction [`replace_na`](https://tidyr.tidyverse.org/reference/replace_na.html)\ndu package _tidyr_, en conjonction avec `mutate`,\npour transformer les valeurs manquantes en 0.\n\n<details>\n<summary>\nIndice pour cette question\n</summary>\n![](https://github.com/linogaliana/r-geographie/raw/main/exercises/img/mutate.png)\n</details>\n\n\n4. Cr√©er dans la m√™me s√©quence de code les variables suivantes:\n    - `dep`: le d√©partement. Celui-ci peut √™tre cr√©√© gr√¢ce aux deux premiers caract√®res de `code_insee` avec la fonction `str_sub` du _package_ `stringr`[^notecorse]\n    - `transports_total`: les √©missions du secteur transports (somme des deux variables)\n\n<details>\n<summary>\nIndice pour cette question\n</summary>\n![](https://github.com/linogaliana/r-geographie/raw/main/exercises/img/mutate.png)\n</details>\n\n\n5. Ordonner les donn√©es du plus gros pollueur au plus petit \npuis ordonner les donn√©es \ndu plus gros pollueur au plus petit par d√©partement (du 01 au 95). \n\n<details>\n<summary>\nIndice pour cette question\n</summary>\n![](https://github.com/linogaliana/r-geographie/raw/main/exercises/img/arrange.png)\n</details>\n\n6. Calculer les √©missions totales par d√©partements\n\n<details>\n<summary>\nIndice pour cette question\n</summary>\n\n* _\"Grouper par\"_ = `group_by`\n* _\"√©missions totales\"_ = `summarise(sum(***))`\n\n</details>\n\n\n:::\n\n[^na]: Cette hypoth√®se est certainement fausse. Elle est exclusivement\nl√† pour illustrer la cr√©ation de variables via `mutate`.\n\n[^notecorse]: Pour √™tre vraiment pr√©cis, il faudrait modifier les valeurs\nobtenues pour les d√©partements Corse avec la fonction `case_when`\ndu _package_ `dplyr`. Ceci est laiss√© en exercice suppl√©mentaire. \n\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 1\"\nemissions_copy <- emissions %>%\n  select(`INSEE commune`, `Commune`, `Autres transports`, `Autres transports international`)\n```\n  \n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 2\"\nemissions_copy <- emissions_copy %>%\n  rename(\n    code_insee = `INSEE commune`,\n    transports = `Autres transports`,\n    transports_international = `Autres transports international`\n    )\n```\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 3\"\nemissions_copy <- emissions_copy %>%\n  mutate(\n    transports = replace_na(transports),\n    transports_international = replace_na(transports_international)\n    )\n```\n\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 4\"\nemissions_copy <- emissions_copy %>%\n  mutate(\n    dep = str_sub(code_insee, 1, 2),\n    transports_total = transports + transports_international\n    )\n```\n\n```{r}\n#| output: false\n#| code-fold: true\n#| code-summary: \"Solution question 5\"\nemissions_copy %>%\n  arrange(desc(transports_total))\n\nemissions_copy %>%\n  arrange(dep, desc(transports_total))\n```\n\n```{r}\n#| output: false\n#| code-fold: true\n#| code-summary: \"Solution question 6\"\nemissions_copy %>%\n  group_by(dep) %>%\n  summarise(sum(transports_total))\n\n```\n\n## Import de donn√©es de l'Insee\n\nEn ce qui concerne nos informations communales, on va utiliser l'une des plus\nsources de l'Insee les plus utilis√©es : les donn√©es [`Filosofi`](https://www.insee.fr/fr/metadonnees/source/serie/s1172). \nAfin de faciliter la r√©cup√©ration de celles-ci, nous allons\nutiliser le _package_ communautaire `doremifasol` :\n\n```{r}\n#| output: false\n#| echo: true\nlibrary(doremifasol)\nlibrary(tibble)\nfilosofi <- as_tibble(\n  telechargerDonnees(\"FILOSOFI_COM\", date = 2016)\n)\nhead(filosofi)\n```\n\n```{r}\n#| echo: false\nhead(filosofi)\n```\n\n::: {.callout-note}\nLa fonction `as_tibble` nous sert √† transformer le _dataframe_ de base (`doremifasol` \nne fait pas d'_a priori_ sur l'√©cosyst√®me de manipulation adopt√©) en \n_dataframe_ adapt√© √† une exploitation via le `tidyverse`. \n:::\n\n# Nettoyage des donn√©es\n\n:::{.callout-tip}\n## Exercice 2\n\nComme c'est `readr` ou `doremifasol` qui ont\ng√©r√© automatiquement l'import des donn√©es, on va faire un petit\ncontr√¥le qualit√©:\n\n1. Afficher le nom des colonnes de nos _dataframes_ `emissions` et `filosofi`. \nQuelles sont les colonnes communes ? Utiliser la fonction `intersect` et comprendre\nla nature du probl√®me.\n2. Observer la structure de nos jeux de donn√©es (les types des colonnes). Les types fix√©s par d√©faut sont-ils ad√©quats ?\n\nEnsuite, on v√©rifie les dimensions des `DataFrames` et la structure de certaines variables cl√©s.\nEn l'occurrence, les variables fondamentales pour lier nos donn√©es sont les variables communales.\nIci, on a deux variables g√©ographiques: un code commune et un nom de commune. \nOn va donc v√©rifier qu'elles sont bien adapt√©es √† l'analyse statistique.\n\n3. V√©rifier les dimensions des _dataframes_ ;\n4. V√©rifier le nombre de valeurs uniques des variables g√©ographiques dans chaque base. Les r√©sultats apparaissent-ils coh√©rents ?\n5. Identifier dans `filosofi` les noms de communes qui correspondent √† plusieurs codes communes et s√©lectionner leurs codes. En d'autres termes, identifier les `CODGEO` tels qu'il existe des doublons de `LIBGEO` et les stocker dans un dataframe `duplicates`\n\nOn se focalise temporairement sur les observations o√π le libell√© comporte plus de deux codes communes diff√©rents\n\n6. Regarder dans `filosofi` ces observations. Pour mieux y voir, r√©ordonner la base obtenue par order alphab√©tique\n7. D√©terminer la taille moyenne (variable nombre de personnes: `NBPERSMENFISC16`) et quelques statistiques descriptives de ces donn√©es.\nComparer aux m√™mes statistiques sur les donn√©es o√π libell√©s et codes communes co√Øncident\n8. V√©rifier les grandes villes (plus de 100 000 personnes),\nla proportion de villes pour lesquelles un m√™me nom est associ√© √† diff√©rents codes commune.\n9. V√©rifier dans `filosofi` les villes dont le libell√© est √©gal √† Montreuil.\nV√©rifier √©galement celles qui contiennent le terme 'Saint-Denis'\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 1\"\n#| output: false\nstr(emissions)\nintersect(colnames(filosofi), colnames(emissions))\n```\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 2\"\n#| output: false\nstr(filosofi)\nstr(emissions)\n```\n\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 3\"\n#| output: false\ndim(filosofi)\ndim(emissions)\n```\n\n```{r}\n#| output: false\n#| code-fold: true\n#| code-summary: \"Solution question 3\"\n\nemissions %>%\n  select('INSEE commune', 'Commune') %>%\n  summarize(Unique_Count = n_distinct(Commune))\n\nfilosofi %>%\n  select('CODGEO', 'LIBGEO') %>%\n  summarize(Unique_Count = n_distinct(LIBGEO))\n```\n\n```{r}\n#| output: false\n#| code-fold: true\n#| code-summary: \"Solution questions 5 √† 7\"\n\n# Question 5\nduplicates <- filosofi %>%\n  group_by(LIBGEO) %>%\n  summarize(Count = n()) %>%\n  select(LIBGEO, Count) %>%\n  #arrange(desc(Count)) %>%\n  filter(Count > 1)\n\n# Question 6\nfilosofi %>%\n  filter(LIBGEO %in% duplicates$LIBGEO) %>%\n  arrange(LIBGEO)\n\n# Question 7\nfilosofi %>%\n  filter(LIBGEO %in% duplicates$LIBGEO) %>%\n  summarize(Stats = mean(NBPERSMENFISC16, na.rm = TRUE))\n\n# Calculate summary statistics for 'NBPERSMENFISC16' for rows where 'LIBGEO' is not in 'x$LIBGEO'\nfilosofi %>%\n  filter(!(LIBGEO %in% duplicates$LIBGEO)) %>%\n  summarize(Stats = mean(NBPERSMENFISC16, na.rm = TRUE))\n```\n\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 8\"\n\nfilosofi_big <- filosofi %>%\n  filter(NBPERSMENFISC16 > 100000) %>%\n  mutate(probleme = LIBGEO %in% duplicates$LIBGEO)\n\n# Proportion de villes √† probl√®me\nmean_probleme <- filosofi_big %>%\n  summarize(mean(probleme))\n\n# Filter rows where 'probleme' is TRUE\ndf_probleme <- filosofi_big %>%\n  filter(probleme)\n```\n\n<details>\n<summary>\nCe que vous devriez trouver dans les questions 8 et 9\n</summary>\n\nPour la question 8, vous devriez obtenir ceci:\n\n\n```{r}\nhead(df_probleme)\n```\n\nAlors que pour la question 9, vos deux _dataframes_ ressembleront √†\n\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 9\"\n# Question 9\nfilosofi %>%\n  filter(LIBGEO == 'Montreuil')\n\n# Question 10\nfilosofi %>%\n  filter(grepl('Saint-Denis', LIBGEO)) %>%\n  head(10)\n```\n</details>\n\n:::\n\nCe petit exercice permet de se rassurer car les libell√©s dupliqu√©s\nsont en fait des noms de commune identiques mais qui ne sont pas dans le m√™me d√©partement.\nIl ne s'agit donc pas d'observations dupliqu√©es.\nOn se fiera ainsi aux codes communes, qui eux sont uniques.\n\n\n::: {.callout-tip}\n## Exercice 3\n\nOn va commencer l'exploration de donn√©es. Cela implique un peu de\nnettoyage de donn√©es en amont. \n\n1. Renommer la variable `INSEE commune` en `code_insee`[^espace]. \n2. Les deux premiers chiffres des codes communes sont le num√©ro de d√©partement.\nCr√©er une variable de d√©partement `dep` dans `emissions` et dans `filosofi`\nen utilisant la fonction `str_sub` du package `stringr`[^stringr].\n\nCommen√ßons le calcul de nos premi√®res statistiques descriptives. \n\n3. Calculer les √©missions totales par secteur pour chaque d√©partement.\nMettre en _log_ ces r√©sultats dans un objet `emissions_log`.\nLa @fig-sample-log illustre la structure de ces √©missions sur 5 d√©partements\nal√©atoires. \n\n4. Repartir du jeu de donn√©es `emissions`.\nCalculer les √©missions totales par d√©partement et sortir la liste\ndes 10 principaux √©metteurs de CO2 et des 5 d√©partements les moins √©metteurs.\nSans faire de *merge*,\nregarder les caract√©ristiques de ces d√©partements (population et niveau de vie)\n\n[^stringr]: Les fonctionnalit√©s limit√©es du langage de base sur la manipulation\ntextuelle sont rapidement contraignantes. On passe ainsi rapidement √† `stringr`\nm√™me si ce n'est pas l'objet principal du chapitre. \n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 1\"\n#| output: false\nlibrary(stringr)\n\nemissions <- emissions %>%\n  rename('code_insee' = `INSEE commune`)\n```\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 2\"\nemissions <- emissions %>%\n  mutate(dep = str_sub(code_insee, start = 1, end = 2))\nfilosofi <- filosofi %>%\n  mutate(dep = str_sub(CODGEO, start = 1, end = 2))\n```\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 3\"\n#| label: question 3 exo 3\n#| output: false\nemissions_log <- emissions %>%\n    group_by(dep) %>%\n    summarise(across(where(is.numeric), sum, na.rm = TRUE)) %>%\n    mutate(across(where(is.numeric), log))\n```\n\n```{r}\n#| output: false\n#| code-fold: true\n#| code-summary: \"Solution question 4\"\n\n## Emissions totales par d√©partement\nemissions_dep <- emissions %>%\n  mutate(total = rowSums(pick(where(is.numeric)), na.rm = TRUE)) %>%\n  group_by(dep) %>%\n  summarise(total = sum(total))\ngros_emetteurs <- emissions_dep %>%\n  arrange(desc(total)) %>%\n  head(10)\npetits_emetteurs <- emissions_dep %>%\n  arrange(total) %>%\n  head(5)\n\n## Caract√©ristiques de ces d√©partements dans filosofi\ngros_emetteurs_filosofi <- filosofi %>%\n  filter(dep %in% gros_emetteurs$dep) %>%\n  group_by(dep) %>%\n  summarise(across(c('NBPERSMENFISC16','MED16'), \\(x) mean(x, na.rm = TRUE)))\n\nhead(gros_emetteurs_filosofi)\n```\n\n\n```{r}\n#| echo: true\n#| fig-cap: Structure des √©missions de cinq d√©partements al√©atoires\n#| label: fig-sample-log\n#| code-fold: true\n#| code-summary: \"Code pour cr√©er la figure ci-dessous\"\n\nlibrary(tidyr)\nlibrary(ggplot2)\n\nemissions_log_sample <- emissions_log %>%\n  filter(dep %in% sample(unique(dep),5))\n\nemissions_log_sample <- emissions_log_sample %>%\n  pivot_longer(cols = -dep, names_to = \"Category\", values_to = \"Value\")\n\nggplot(emissions_log_sample, aes(x = dep, y = Value, fill = Category)) +\n    geom_bar(stat = \"identity\") +\n    labs(x = \"Department\", y = \"Value\") +\n    theme_minimal() +\n    theme(axis.text.x = element_text(angle = 45, hjust = 1)) + scale_fill_viridis_d()\n```\n\n\n<details>\n<summary>\nExemple d'utilisation de `str_sub`\n</summary>\n```r\nlibrary(stringr)\ndf %>% mutate(x = str_sub(y, start = 3, end = 5))\n```\n\n</details>\n\n:::\n\n[^espace]: L'espace dans le nom de la variable est emb√™tant. Pour pouvoir\nutiliser le nom de cet variable dans `rename`, il va falloir utiliser\ndes backticks, c'est-√†-dire ` INSEE commune `.\n\n\n# Restructurer des donn√©es\n\nOn pr√©sente g√©n√©ralement deux types de donn√©es : \n    \n* format __wide__: les donn√©es comportent des observations r√©p√©t√©es, pour un m√™me individu (ou groupe), dans des colonnes diff√©rentes \n* format __long__: les donn√©es comportent des observations r√©p√©t√©es, pour un m√™me individu, dans des lignes diff√©rentes avec une colonne permettant de distinguer les niveaux d'observations\n\nUn exemple de la distinction entre les deux peut √™tre pris √† l'ouvrage de r√©f√©rence d'Hadley Wickham, *R for Data Science*:\n\n![Donn√©es _long_ (gauche) et _wide_ (droite) (source: *R for Data Science*)](https://d33wubrfki0l68.cloudfront.net/3aea19108d39606bbe49981acda07696c0c7fcd8/2de65/images/tidy-9.png)\n\nOn est souvent amen√© avec {{< fa brands r-project >}} √† restructurer les donn√©es\npour les allonger (_wide to long_) et les √©largir (_long to wide_). \nC'est le package _tidyr_ (qui appartient au _tidyverse_) qui permet\nde faire ce type de transformations.\n\nL'aide m√©moire suivante aidera √† se rappeler les fonctions √† appliquer si besoin:\n\n![](https://scienceparkstudygroup.github.io/r-lesson-based-on-ohi-data-training/img/rstudio-cheatsheet-spread-gather-sep-unite.png){width=\"80%\" fig-align=\"center\"}\n\nLe fait de passer d'un format *wide* au format *long* (ou vice-versa)\npeut √™tre extr√™mement pratique car certaines fonctions sont plus ad√©quates sur une forme de donn√©es ou sur l'autre.\n\nEn r√®gle g√©n√©rale, les formats *long* sont souvent pr√©f√©rables car il est\nplus facile d'it√©rer sur des lignes que sur des colonnes du fait de\nla nature vectorielle de {{< fa brands r-project >}}.\nC'est notamment\nla forme de donn√©es privil√©gi√©e pour pr√©parer des graphiques avec `ggplot`, \nque nous d√©couvrirons dans le prochain chapitre. \n\n\n:::{.callout-tip}\n## Exercice 4: la transformation _wide to long_\n1. Restructurer les donn√©es au format *long* pour avoir des donn√©es d'√©missions par secteur en gardant comme niveau d'analyse la commune (attention aux autres variables identifiantes).\n2. Faire la somme par secteur et repr√©senter graphiquement un _barplot_[^barplot] \n3. Garder, pour chaque d√©partement, le secteur le plus polluant\n\n[^barplot]: vous pouvez\nutiliser directement le morceau de code d'aide si vous n'√™tes pas familiers de `ggplot`\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 1\"\n\nlibrary(tidyr)\n\ndf_long <- emissions %>%\n  pivot_longer(cols = -c(code_insee, Commune, dep),\n               names_to = \"secteur\",\n               values_to = \"emissions\")\n```\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 2\"\n\ndf_long_summary <- df_long %>%\n  group_by(secteur) %>% summarise(emissions = sum(emissions, na.rm = TRUE))\n```\n\n<details>\n<summary>Graphique √† r√©aliser pour la question 2</summary>\n\nUne fois le _dataframe_ `df_long_summary` cr√©√©, le code minimal\npour r√©aliser le _barplot_ voulu est:\n\n```{r}\n#| echo: true\nggplot(df_long_summary) +\n  geom_bar(\n    aes(y = secteur, x = emissions),\n    stat ='identity'\n  )\n```\n\nPas besoin d'aller plus loin pour le moment, nous ferons plus\nde `ggplot` ult√©rieurement. \n\n</details>\n\n```{r}\n#| output: false\n#| code-fold: true\n#| code-summary: \"Solution question 3\"\ndf_long_dep <- df_long %>%\n  group_by(secteur, dep) %>%\n  summarise(emissions = sum(emissions, na.rm = TRUE)) %>%\n  arrange(desc(dep), desc(emissions)) %>%\n  group_by(dep) %>%\n  slice_head(n = 1)\n```\n\n```{r}\n#| echo: false\nhead(df_long_dep)\n```\n\n\n:::\n\n\n::: {.callout-tip}\n## Exercice 5: _long to wide_\n\nTO DO\n:::\n\n\n# Combiner les donn√©es\n\nUne information que l'on cherche √† obtenir s'obtient de moins en moins √† partir d'une unique base de donn√©es. Il devient commun de devoir combiner des donn√©es issues de sources diff√©rentes. \n\nNous allons ici nous focaliser sur le cas le plus favorable qui est la situation o√π une information permet d'apparier de mani√®re exacte deux bases de donn√©es (autrement nous serions dans une situation, beaucoup plus complexe, d'appariement flou). La situation typique est l'appariement entre deux sources de donn√©es selon un identifiant individuel ou un identifiant de code commune, ce qui est notre cas.\n\nIl est recommand√© de lire [ce guide assez complet sur la question des jointures avec {{< fa brands r-project >}}](https://www.book.utilitr.org/03_fiches_thematiques/fiche_joindre_donnees) qui donne des recommandations √©galement utiles en `Python` {{< fa brands python >}}.\n\nDans le langage courant du statisticien,\non utilise de mani√®re indiff√©rente les termes *merge* ou *join*. Le deuxi√®me terme provient de la syntaxe `SQL` et c'est celui qui est plut√¥t utilis√©\nquand on code avec `dplyr`. \n\n<details>\n\n<summary>\nLes diff√©rents type de _join_ disponibles dans `dplyr`\n</summary>\n\n![](https://rafalab.dfci.harvard.edu/dsbook/wrangling/img/joins.png){width=80%}\n\n</details>\n\n::: {.callout-tip}\n## Exercice 6: enrichir les donn√©es d'√©missions\n\nEn premier lieu, on va calculer l'empreinte carbone de chaque commune. \n\n1. Calculer les √©missions totales en utilisant la commande suivante\n(comme celle-ci est complexe, nous la donnons directement):\n\n```r\nemissions <- emissions %>%\n  mutate(total = rowSums(pick(where(is.numeric)), na.rm = TRUE))\n```\n\n\n2. Faire une jointure √† gauche entre les donn√©es d'√©missions et les donn√©es de cadrage[^notebiais].\n\n[^notebiais]: Id√©alement, il serait n√©cessaire de s'assurer que cette jointure n'introduit\npas de biais. En effet, comme nos ann√©es de r√©f√©rence ne sont pas forc√©ment identiques,\nil peut y avoir un _mismatch_ entre nos deux sources. Le TP √©tant d√©j√† long, nous n'allons pas dans cette voie. Les lecteurs int√©ress√©s pourront effectuer une telle analyse en exercice suppl√©mentaire.\n\n3. Calculer l'empreinte carbone (√©missions totales / population).\n\nA ce stade nous pourrions avoir envie d'aller vers la mod√©lisation pour essayer d'expliquer\nles d√©terminants de l'empreinte carbone √† partir de variables communales. \nUne approche inf√©rentielle n√©cessite n√©anmoins pour √™tre pertinente de\nv√©rifier en amont des statistiques descriptives.\n\n4. Utiliser le code suivant pour sortir un histogramme en niveau puis en log de l'empreinte carbone communale ;\n\n```r\nggplot(emissions_merged) +\n  geom_histogram(aes(x = empreinte, y = after_stat(density))) +\n  scale_x_log10()\n```\n\n5. Pour chaque ville, comparer l'empreinte carbone √† la m√©diane du d√©partement. En relatif, quelles sont les villes particuli√®rement vertueuses (c'est-√†-dire celles qui ont des √©missions bien inf√©rieures √† la moyenne d√©partementale) ?\n\nAvec une meilleure compr√©hension de nos donn√©es, nous nous rapprochons\nde la statistique inf√©rentielle. N√©anmoins, nous avons jusqu'√† pr√©sent\nconstruit des statistiques univari√©es mais n'avons pas cherch√© √† comprendre\nles r√©sultats en regardant le lien avec d'autres variables. \nCela nous am√®ne vers la statistique bivari√©e, notamment l'analyse des corr√©lations. \nCe travail est important puisque toute mod√©lisation ult√©rieure consistera √† \nraffiner l'analyse des corr√©lations pour tenir compte des corr√©lations crois√©es\nentre multiples facteurs. On propose ici de faire cette analyse\nde mani√®re minimale. \n\n6. Regarder la corr√©lation entre les variables de cadrage et l'empreinte carbone (la solution est donn√©e, car les manipulations ne sont pas √©videntes).\nCertaines variables semblent-elles pouvoir potentiellement influer sur l'empreinte carbone ?\n\n```{r}\n#| output: false\n#| code-fold: true\n#| code-summary: \"Solution question 1\"\n\nemissions <- emissions %>%\n  mutate(total = rowSums(pick(where(is.numeric)), na.rm = TRUE))\n```\n\n```{r}\n#| output: false\n#| code-fold: true\n#| code-summary: \"Solution question 2\"\nemissions_merged <- emissions %>%\n  left_join(filosofi, by = c(\"code_insee\" = \"CODGEO\"))\n```\n\n```{r}\n#| output: false\n#| code-fold: true\n#| code-summary: \"Solution question 3\"\nemissions_merged <- emissions_merged %>%\n  mutate(empreinte = total/NBPERSMENFISC16)\n```\n\n```{r}\n#| output: false\n#| code-fold: true\n#| code-summary: \"Solution question 4\"\nggplot(emissions_merged) +\n  geom_histogram(aes(x = empreinte, y = after_stat(density))) +\n  scale_x_log10()\n```\n\n```{r}\n#| output: false\n#| code-fold: true\n#| code-summary: \"Solution question 5\"\n#| echo: true\nemissions_merged <- emissions_merged %>%\n  rename(departement = dep.x) %>%\n  group_by(departement) %>%\n  mutate(empreinte_mediane = median(empreinte, na.rm = TRUE)) %>%\n  mutate(empreinte_relative = empreinte/empreinte_mediane)\n\nemissions_merged %>% arrange(empreinte_relative)\n```\n\n\n\n```{r}\n#| output: false\n#| code-fold: true\n#| code-summary: \"Solution question 6\"\n\nlibrary(tibble)\n\ncorrelations <- cor(\n  emissions_merged %>% ungroup() %>% select(where(is.numeric)),\n  use=\"complete.obs\"\n  )[,'empreinte']\n\ncorrelations <- enframe(correlations) %>%\n  filter(name %in% colnames(filosofi)) %>%\n  arrange(desc(abs(value)))\n```\n\nVoici une visualisation rapide des corr√©lations √† l'empreinte carbone:\n\n```{r}\nggplot(correlations) + geom_bar(aes(x = value, y = name), stat = \"identity\") +\n  scale_y_discrete(limits = correlations$name) \n```\n\n:::\n\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":true,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../styles.css"],"toc":true,"number-sections":true,"output-file":"r-wrangling.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.8.27","author":"Lino Galiana","theme":"cosmo","code-annotations":"hover","title":"Importer et manipuler des donn√©es avec {{< fa brands r-project >}}"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}
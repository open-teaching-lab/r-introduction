{"title":"Manipuler des donn√©es spatiales avec `sf`","markdown":{"yaml":{"title":"Manipuler des donn√©es spatiales avec `sf`","echo":true,"number-sections":true},"headingText":"Note sur les annotations","containsRefs":false,"markdown":"\n\n::: {.badge}\n<a href=\"https://datalab.sspcloud.fr/launcher/ide/rstudio?version=1.15.13&networking.user.enabled=true&onyxia.friendlyName=%C2%ABrstudio-cours-ENS%C2%BB¬ª&networking.user.enabled=true&onyxia.friendlyName=¬´rstudio-cours-ENS¬ª\" target=\"_blank\" rel=\"noopener\"><img src=\"https://img.shields.io/badge/Tester%20via%20SSP%20cloud%20-%20SSPCloud?logo=R&labelColor=black&color=%231965b8\" alt=\"Onyxia\"></a><br>\n:::\n\n<details>\n<summary>\nD√©rouler les _slides_ ci-dessous ou [cliquer ici](/slides/geospatial.qmd)\npour afficher les slides en plein √©cran.\n</summary>\n\n\n``` {.yaml code-preview=\"/slides/geospatial.qmd\"}\n```\n\n</details>\n\n\nDans ce TP,\nnous allons apprendre √† importer et\nmanipuler des donn√©es spatiales avec\n{{< fa brands r-project >}}.\n\nCe logiciel propose\ndes fonctionnalit√©s tr√®s int√©ressantes pour ce type de\ndonn√©es complexes qui le rendent capable de se comporter\ncomme un SIG. Gr√¢ce √† la librairie [`sf`](https://r-spatial.github.io/sf/), une extension\nde `dplyr` aux donn√©es spatiales, les\ndonn√©es g√©ographiques pourront √™tre manipul√©es\ncomme n'importe quel type de donn√©es avec {{< fa brands r-project >}}.\nLa complexit√© induite par la dimension spatiale ne sera pas ressentie. \n\n\n<details>\n<summary>\n`sf`, une association de tables de donn√©es classiques √† des g√©om√©tries\n</summary>\n![](https://user-images.githubusercontent.com/520851/50280460-e35c1880-044c-11e9-9ed7-cc46754e49db.jpg){width=\"70%\"}\n</details>\n\nSi vous √™tes int√©ress√©s par `Python` {{< fa brands python >}},\nune version tr√®s proche de ce TP est disponible dans [mon cours de l'ENSAE](https://pythonds.linogaliana.fr/content/manipulation/03_geopandas_TP.html).\n\n\n```{r}\n#| eval: false\n#| echo: true\nremotes::install_github(\"linogaliana/cartiflette-r\")\ninstall.packages(\"leaflet\")\n```\n\nDans ce chapitre, nous allons utiliser les packages\nsuivants:\n\n\n```{r}\n#| echo: true\n#| output: false\nlibrary(units)\nlibrary(dplyr)\nlibrary(sf)\nlibrary(ggplot2)\nlibrary(mapsf)\nlibrary(leaflet)\nlibrary(cartiflette)\n```\n\nCe chapitre illustre √† partir d'exemples pratiques certains principes\ncentraux de l'analyse de donn√©es:\n\n- Manipulations sur les attributs des jeux de donn√©es ;\n- Manipulations g√©om√©triques ;\n- Gestion des projections cartographiques ;\n- Cr√©ation rapide de cartes (ce sera approfondi dans un prochain chapitre).\n\n\n::: {.callout-note collapse=\"true\"}\n\nCertains exemples de code pr√©sentent des annotations sur le c√¥t√©,\npassez votre souris dessus pour les afficher, comme ci-dessous\n\n```{r}\n#| echo: true\n#| output: false\n\"une annotation explicative m'accompagne √† droite\" #<1>\n```\n1. Je m'affiche quand on passe la souris sur moi üê≠ !\n\n:::\n\n\n## D√©couverte des objets g√©ographiques \n\nDans cette partie,\nnous utiliserons\nles fonds de carte de l'IGN dont\nla mise √† disposition est facilit√©e\npar le projet [`cartiflette`](https://github.com/InseeFrLab/cartiflette.git)[^cartiflette-r].\n\n[^cartiflette-r]:\n  La librairie {{< fa brands r-project >}} est exp√©rimentale mais \n  les prochaines semaines devraient permettre de combler ce manque. \n  Une documentation interactive illustrant le code n√©cessaire pour reproduire\n  telle ou telle carte est disponible sur [linogaliana.github.io/cartiflette-website](https://linogaliana.github.io/cartiflette-website/index.html).\n\n\n::: {.callout-tip}\n## Exercice 1: d√©couverte des objets g√©ographiques\n\nEn premier lieu, on r√©cup√®re des donn√©es g√©ographiques gr√¢ce\nau _package_ `cartiflette`.\n\n1. Utiliser\nle code ci-dessous pour\nt√©l√©charger les donn√©es communales (produit `Admin Express` de l'IGN)\ndes d√©partements de la petite couronne (75, 92, 93 et 94)\nde mani√®re simplifi√©e gr√¢ce au _package_\n`cartiflette`:\n\n```{r}\n#| echo: true\n#| output: false\n#| label: download-borders-communes\n# 1. Chargement des donn√©es de cartiflette\ncommunes_borders <- download_vectorfile_url_all(\n    crs = 4326,\n    values = c(\"75\", \"92\", \"93\", \"94\"),\n    borders=\"COMMUNE\",\n    vectorfile_format=\"geojson\",\n    filter_by=\"DEPARTEMENT\",\n    source=\"EXPRESS-COG-CARTO-TERRITOIRE\",\n    year=2022)\n```\n\n2. Regarder les premi√®res lignes des donn√©es. Identifier la diff√©rence avec\nun _dataframe_ standard. \n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 2\"\n#| output: false\n# 2) Regarder les premi√®res lignes\nhead(communes_borders)\n```\n\n<details>\n<summary>\nPremi√®res lignes des donn√©es\n</summary>\n```{r}\n#| echo: false\n# 2) Regarder les premi√®res lignes\nhead(communes_borders)\n```\n</details>\n\n3. Afficher le `crs` de `communes_borders`. Ce dernier contr√¥le la\ntransformation de l'espace tridimensionnel terrestre en une surface plane.\nUtiliser `st_transform` pour transformer les donn√©es en Lambert 93, le \nsyst√®me officiel (code EPSG 2154). \n\n```{r}\n#| output: false\n#| code-fold: true\n#| code-summary: \"Solution question 3\"\n\n# 3) Afficher le crs\nsf::st_crs(communes_borders)\n# Les donn√©es sont en WGS84, on les reprojette en lambert 93\ncommunes_borders <- communes_borders %>% st_transform(2154)\n```\n\n4. Afficher les communes des Hauts de Seine (d√©partement 92) et repr√©senter rapidement la carte.\n\n```{r}\n#| label: plot-92\n#| output: false\n#| code-fold: true\n#| code-summary: \"Solution question 4\"\n\n# 4) afficher les communes du d√©partement 92\nhds <- communes_borders %>% filter(INSEE_DEP == \"92\")\nmap_92 <- ggplot(hds) +\n    geom_sf(fill = \"white\") + theme_void()\n```\n\n5. Ne conserver que Paris et r√©pr√©senter les fronti√®res sur une carte : quel est le probl√®me pour\nune analyse de Paris intramuros?\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 5\"\nparis_raw <- communes_borders %>% filter(INSEE_DEP == \"75\")\nmap_paris_raw <- ggplot(paris_raw) +\n    geom_sf(fill = \"white\") + theme_void()\n```\n\nOn remarque rapidement le probl√®me. \nOn ne dispose ainsi pas des limites des arrondissements parisiens, ce\nqui appauvrit grandement la carte de Paris. \n\n6. Cette fois, utiliser l'argument `borders=\"COMMUNE_ARRONDISSEMENT\"` pour obtenir\nun fonds de carte consolid√© des communes avec les arrondissements dans les grandes villes. \nConvertir en Lambert 93. \n\n```{r}\n#| output: false\n#| code-fold: true\n#| code-summary: \"Solution question 6\"\n\npetite_couronne <- download_vectorfile_url_all(\n    crs = 4326,\n    values = c(\"75\", \"92\", \"93\", \"94\"),\n    borders=\"COMMUNE_ARRONDISSEMENT\",\n    vectorfile_format=\"geojson\",\n    filter_by=\"DEPARTEMENT\",\n    source=\"EXPRESS-COG-CARTO-TERRITOIRE\",\n    year=2022) %>%\n  st_transform(2154)\npetite_couronne_mercator <- petite_couronne %>%\n  st_transform(4326)\n\nmap_paris_arrondissements <- ggplot(petite_couronne) +\n    geom_sf(fill = \"white\") + theme_void()\n```\n\n\n:::\n\n\n<details>\n\n<summary>\nSi vous d√©sirez observer l'aspect de la\ncarte du 92 (question 4), d√©roulez cette partie.\n</summary>\n\n```{r}\n#| echo: false\nmap_92\n```\n\n</details>\n\n<details>\n<summary>\nCarte de Paris attendue √† la question 5 et √† la question 6\n</summary>\n\nA la question 5, Paris intra-muros est bien pauvre: \n\n```{r}\n#| echo: false\n# 5) Repr√©senter la carte de Paris. Quel est le probl√®me ?\nmap_paris_raw\n```\n\nA l'issue de la  question 6, on a bien une carte de la petite couronne avec\ndes arrondissements:\n\n```{r}\n#| echo: false\n# 6) Repr√©senter la carte de Paris avec arrondissements\nmap_paris_arrondissements\n```\n\n\n</details>\n\n## Le syst√®me de projection\n\nUn concept central dans les logiciels de SIG est la notion de \n__projection__. L'exercice pr√©c√©dent imposait parfois certaines projections\nsans expliquer l'importance de ces choix. {{< fa brands r-project >}}, comme\ntout SIG, permet une gestion coh√©rente des projections. \n\nL'exercice suivant vise √† introduire aux principales\nfonctionnalit√©s de {{< fa brands r-project >}}\n√† ce propos. Il illustre les probl√®mes communs que peuvent rencontrer\nles g√©ographes dans la gestion des syst√®mes de projection. \n\nObservez les variations significatives\nde proportions pour certains pays selon les projections\nchoisies:\n\n```{ojs}\n//| echo: false\nhtml`<div>${container_projection}</div>`\n``` \n\n{{< include \"../utils/play_projection_d3.qmd\" >}}\n\n```{ojs}\n//| echo: false\nwidth_projected_map = screen.width/2\n```\n\n\n\n::: {.callout-tip}\n## Exercice 2: Les projections, repr√©sentations et approximations\n\nVoici un code utilisant encore\n`cartiflette` \npour r√©cup√©rer les fronti√®res fran√ßaises (d√©coup√©es par r√©gion):\n\n```{r}\n#| output: false\n#| echo: true\nfrance <- download_vectorfile_url_all(\n      values = \"metropole\",\n      crs = 4326,\n      borders = \"REGION\",\n      vectorfile_format=\"geojson\",\n      filter_by=\"FRANCE_ENTIERE\",\n      source=\"EXPRESS-COG-CARTO-TERRITOIRE\",\n      year=2022)\n```\n\n```{r}\n# eval: true\nst_crs(france) <- 4326\nst_crs(france$geometry) <- 4326\n```\n\n1. S'amuser √† repr√©senter les limites de la France avec plusieurs projections:\n\n- Mercator WGS84 (EPSG: 4326)\n- Projection healpix (`+proj=healpix +lon_0=0 +a=1`)\n- Projection pr√©vue pour Tahiti (EPSG: 3304)\n- Projection Albers pr√©vue pour Etats-Unis (EPSG: 5070)\n\n2. Utiliser la fonction `st_area` sur calculer la superficie en $km^2$\ndes r√©gions fran√ßaises dans les deux syst√®mes de projection suivants: \nWGS84 (EPSG: 4326) et Lambert 93 (EPSG: 2154). Calculer la diff√©rence en $km^2$\npour chaque r√©gion.\n:::\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 1\"\n#| eval: false\n#| output: false\nfrance_2154 <- france %>% sf::st_transform(2154)\nfrance_healpix <- france %>% sf::st_transform(\"+proj=healpix +lon_0=0 +a=1\")\nfrance_5070 <- france %>% sf::st_transform(5070)\nfrance_3304 <- france %>% sf::st_transform(3304)\n```\n\nAvec la question 1 illustrant quelques cas pathologiques,\non comprend que les projections ont un effet d√©formant\nqui se voit bien lorsqu'on les repr√©sente c√¥te √† c√¥te sous\nforme de cartes :\n\n```{r}\n#| eval: false\n#| label: fig-effet-mercator\n#| fig-cap: \"Comparaison des projections\"\n#| fig-subcap: \n#|   - \"Mercator WGS84 (EPSG: 4326)\"\n#|   - \"Projection healpix (+proj=healpix +lon_0=0 +a=1)\"\n#|   - \"Projection pr√©vue pour Tahiti (EPSG: 3304)\"\n#|   - \"Projection Albers pr√©vue pour Etats-Unis (EPSG: 5070)\"\n#| layout-ncol: 2\n\nggplot(france) +\n    geom_sf(fill = \"white\") + theme_void()\n\nggplot(france_healpix) +\n    geom_sf(fill = \"white\") + theme_void()\n\nggplot(france_3304) +\n    geom_sf(fill = \"white\") + theme_void()\n\nggplot(france_5070) +\n    geom_sf(fill = \"white\") + theme_void()\n```\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 2\"\n\nmismatch_france <- france %>%\n  mutate(superficie_4326 = set_units(st_area(.), \"km^2\")) %>%\n  st_transform(2154) %>%\n  mutate(superficie_2154 = set_units(st_area(.), \"km^2\")) %>%\n  mutate(mismatch = superficie_2154-superficie_4326) %>%\n  select(NOM, superficie_4326, superficie_2154, mismatch)\n```\n\nCependant le probl√®me n'est pas que visuel, il est √©galement\nnum√©rique. Les calculs g√©om√©triques am√®nent √† des diff√©rences\nassez notables selon le syst√®me de r√©f√©rence utilis√©.\n\n<details>\n<summary>\nVoir le tableau des approximations pour chaque r√©gion\n</summary>\n```{r}\nmismatch_france %>% arrange(desc(mismatch))\n```\n</details>\n\nOn peut repr√©senter ces approximations sur une carte[^notecarte] pour se faire\nune id√©e des r√©gions o√π l'erreur de mesure est la plus importante.\n\n[^notecarte]: Cette carte n'est pas trop soign√©e,\nc'est normal nous verrons comment\nfaire de belles cartes ult√©rieurement.\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 2, suite\"\n\n#| label: fig-erreur-mesure\n#| fig-cap: Approximations li√©es au syst√®me de projection WGS 84\nggplot(mismatch_france) +\n  geom_sf(aes(fill = as.numeric(mismatch))) +\n  scale_fill_gradient2() +\n  labs(title = \"Approximations li√©es √† la projection\", fill = \"km¬≤\") +\n  theme_void() + theme(legend.position = \"bottom\")\n```\n\nCe type d'erreur de mesure est normal √† l'√©chelle du territoire fran√ßais. \nLes projections h√©rit√®res du Mercator d√©forment les distances,\nsurtout lorqu'on se rapproche de l'√©quateur ou des p√¥les. \n\n::: {#fig-mercator}\n\n![Exemple de reprojection de pays depuis le site [thetruesize.com](https://www.thetruesize.com/)](https://pythonds.linogaliana.fr/content/manipulation/truesize.png){#fig-surus}\n\n![\"Don't trust the Mercator projection\" sur `Reddit`](img/mercator.jpg){#fig-mercator-funny}\n\nLa projection Mercator, une vision d√©formante\n:::\n\nPour aller plus loin, la carte interactive\nsuivante, construite par Nicolas Lambert, issue de\nce [_notebook_ `Observable`](https://observablehq.com/@neocartocnrs/impact-of-projections-on-areas), illustre l'effet\nd√©formant de la projection Mercator, et de quelques unes autres,\nsur notre perception de la taille des pays.\n\n<details>\n<summary>\nVoir la carte interactive\n</summary>\n```{ojs}\nhtml`<div class=\"grid-container\">\n  <div class=\"viewof-projection\">${viewof projectionBertin}</div>\n  <div class=\"viewof-mycountry\">${viewof mycountry}</div>\n  <div class=\"map-bertin\">${mapBertin}</div>\n</div>`\n```\n\n</details>\n\n```{ojs}\nimport {map as mapBertin, viewof projection as projectionBertin, viewof mycountry} from \"@neocartocnrs/impact-of-projections-on-areas\"\n```\n\n\n\nIl n'est donc pas suprenant que nos d√©formations soient exacerb√©es aux\nextr√®mes du territoire m√©tropolitain. \nSi les approximations sont l√©g√®res sur de petits territoires,\nles erreurs peuvent √™tre \nnon n√©gligeables √† l'√©chelle de la France.\n\nIl faut donc syst√©matiquement\nrepasser les donn√©es dans le syst√®me de projection Lambert 93 (le\nsyst√®me officiel pour la m√©tropole) avant d'effectuer des calculs g√©om√©triques.\n\n\n\n## Utiliser des donn√©es g√©ographiques comme des couches graphiques\n\n\nSouvent, le d√©coupage communal ne sert qu'en fond de cartes, pour donner des\nrep√®res. En compl√©ment de celui-ci, on peut d√©sirer exploiter\nun autre jeu de donn√©es.\n\nOn va partir des donn√©es de localisation des\nstations velib, \ndisponibles [sur le site d'open data de la ville de Paris](https://opendata.paris.fr/explore/dataset/velib-emplacement-des-stations/table/) et \nrequ√™tables directement en utilisant un URL\n\n\n```{r}\n#| echo: true\nurl <- \"https://opendata.paris.fr/explore/dataset/velib-emplacement-des-stations/download/?format=geojson&timezone=Europe/Berlin&lang=fr\"\n```\n\n\nDans le prochain exercice, nous proposons de cr√©er rapidement une \ncarte comprenant trois couches:\n\n- Les localisations de stations sous forme de points ;\n- Les bordures des communes et arrondissements pour contextualiser ;\n- Les bordures des d√©partements en traits plus larges pour contextualiser √©galement. \n\nNous irons plus loin dans le travail cartographique dans le prochain\nchapitre. Mais √™tre en mesure de positionner rapidement\nses donn√©es sur une carte est\ntoujours utile dans un travail exploratoire. \n\nEn amont de l'exercice,\nutiliser la fonction suivante du _package_ `cartiflette` pour r√©cup√©rer\nle fonds de carte des d√©partements de la petite couronne:\n\n```{r}\n#| echo: true\n#| output: false\nidf <- download_vectorfile_url_all(\n      values = \"11\",\n      crs = 4326,\n      borders = \"DEPARTEMENT\",\n      vectorfile_format=\"geojson\",\n      filter_by=\"REGION\",\n      source=\"EXPRESS-COG-CARTO-TERRITOIRE\",\n      year=2022)\npetite_couronne_departements <- idf %>%\n  filter(INSEE_DEP %in% c(\"75\",\"92\",\"93\",\"94\"))\n```\n\n\n\n::: {.callout-tip}\n## Exercice 3: importer et explorer les donn√©es velib\n\nOn commence par r√©cup√©rer les donn√©es n√©cessaires √† la production\nde cette carte.\n\n1. En utilisant l'URL pr√©c√©dent, importer les donn√©es velib sous le nom `station`\n2. V√©rifier la projection g√©ographique de `station` (attribut `crs`). Si celle-ci est diff√©rente des donn√©es communales, reprojeter ces\nderni√®res dans le m√™me syst√®me de projection que les stations de v√©lib\n3. Ne conserver que les 50 principales stations (variable `capacity`)\n\nOn peut maintenant construire la carte de mani√®re s√©quentielle avec `ggplot`\n\n4. En premier lieu, gr√¢ce √† `geom_sf`, \nrepr√©senter exclusivement les positions des stations\net ajuster la taille en fonction de la variable `capacity`\n\n5. Ajouter la couche des communes d'arrondissements et des communes\n    + Comme ces limites administratives sont stock√©es dans un _dataframe_ diff√©rent, il va falloir utiliser l'argument `data`\n    + Utiliser `fill = \"transparent\"` pour que l'int√©rieur du polygone ne masque pas nos points\n\n6. Ajouter la couche des d√©partements\n\n7. En supposant que votre objet `ggplot` s'appelle `carte`, vous pouvez\nutiliser le code suivant pour am√©liorer rapidement l'esth√©tique\n\n```r\ncarte +\n  theme_void() +\n  theme(legend.position = \"bottom\") +\n  guides(color = \"none\", size = guide_legend(title.position=\"top\", title.hjust = 0.5)) +\n  labs(size = \"Capacit√© de la station\", title = \"Les 50 principales stations de v√©lib\")\n```\n\n\n:::\n\n```{r}\n#| output: false\n#| code-fold: true\n#| code-summary: \"Solution question 1\"\n# 1. Importer les donn√©es velib\nstations <- st_read(url)\n```\n\n```{r}\n#| output: false\n#| code-fold: true\n#| code-summary: \"Solution question 2\"\n# 2. Reprojection\nst_crs(stations)\nstations <- stations %>% \n  st_transform(st_crs(petite_couronne))\n```\n\n\n```{r}\n#| output: false\n#| code-fold: true\n#| code-summary: \"Solution question 3\"\n# 3. Principales stations\nprincipales_stations <- stations %>%\n  arrange(desc(capacity)) %>%\n  head(50)\n```\n\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 4\"\n# 4. Principales stations sous forme de nuage de points\ncarte <- ggplot(principales_stations) +\n  geom_sf(aes(color = \"red\", size = capacity))\n```\n\n<details>\n<summary>\nLes stations plac√©es sur un plan, √† l'issue de la question 4\n</summary>\n```{r}\ncarte\n```\n</details>\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 5\"\n# Question 5\ncarte <- carte + geom_sf(data = petite_couronne, fill = \"transparent\")\n```\n\n<details>\n<summary>\nAjout d'une couche d'arrondissements (question 5)\n</summary>\n\n```{r}\ncarte\n```\n</details>\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 6\"\n# Question 6\ncarte <- carte +\n  geom_sf(data = petite_couronne_departements, fill = \"transparent\", color = \"blue\")\n```\n\n<details>\n<summary>\nAjout de la couche des d√©partements (question 6)\n</summary>\n\n```{r}\ncarte\n```\n\n</details>\n\nLa carte finalis√©e (question 7), obtenue gr√¢ce √† une demi-douzaine de lignes\nde code seulement, est ainsi:\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 7\"\n# Question 7\ncarte +\n  theme_void() +\n  theme(legend.position = \"bottom\") +\n  guides(color = \"none\", size = guide_legend(title.position=\"top\", title.hjust = 0.5)) +\n  labs(size = \"Capacit√© de la station\", title = \"Les 50 principales stations de v√©lib\")\n```\n\n\n\n\n## Jointures spatiales\n\nLes jointures attributaires fonctionnent comme avec un `tibble` classique.\nPour conserver un objet spatial *in fine*, il faut faire attention √† utiliser en premier (base de gauche) l'objet `sf`.\nEn revanche, l'un des int√©r√™ts des objets `sf` est qu'on peut √©galement faire une jointure sur la dimension spatiale gr√¢ce √† plusieurs fonctions. Les jointures les plus communes sont:\n\n| Fonction |\tOp√©ration |\n|----------|------------|\n|`st_intersects()` | \tQuelles g√©om√©tries de x intersectent celles de y ? |\n|`st_contains()` | \tQuelles g√©om√©tries de x contiennent celles de y ? |\n|`st_disjoint()` | \tQuelles g√©om√©tries de x sont disjointes √† celles de y ? |\n|`st_is_within_distance()` | \tQuelles g√©om√©tries de x est √† moins de m/km de celles de y ? |\n\nLa documentation √† laquelle se\nr√©f√©rer est [ici](https://cran.r-project.org/web/packages/sfnetworks/vignettes/sfn03_join_filter.html). \nUne version p√©dagogique se trouve dans la documentation [`utilitR`](https://www.book.utilitr.org/03_fiches_thematiques/fiche_donnees_spatiales#joindre-des-donn%C3%A9es-g%C3%A9ographiques-et-attributaires). \n\n\n::: {.callout-tip}\n## Exercice 4: Associer les stations aux communes et arrondissements auxquels elles appartiennent\n\nDans cet exercice, on va supposer que :\n\n- les localisations des stations `velib` \nsont stock√©es dans un _dataframe_ nomm√© `stations`\n- les donn√©es administratives\nsont dans un _dataframe_ nomm√© `petite_couronne`.\n\n1. Faire une jointure spatiale pour enrichir les donn√©es de stations en y ajoutant des informations de `petite_couronne`. Appeler cet objet `stations_info`\n2. Cr√©er les objets `stations_19e` et `arrondissement_19e` pour stocker, respectivement, \nles stations appartenant au 19e et les limites de l'arrondissement\n2. Repr√©senter la carte des stations du 19e arrondissement avec le code suivant:\n\n```r\npetite_couronne %>% filter(INSEE_DEP == 75) %>%\n  ggplot() +\n    geom_sf(aes(fill = grepl(\"19e\", NOM)), alpha = 0.1) +\n    geom_sf(data = stations_19e, color = \"royalblue\") +\n    scale_fill_viridis_d() +\n    theme_void() +\n    theme(legend.position = \"none\")\n```\n\n3. Compter le nombre de stations velib et le nombre de places velib par arrondissement ou commune. Repr√©senter sur une carte chacune des informations\n4. Repr√©senter les m√™mes informations mais en densit√© (diviser par la surface de l'arrondissement ou commune en km2)\n5. (optionnel) Choisir une des cartes de densit√© et la nettoyer (retirer les axes, mettre les titres...)\n\n:::\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 1\"\nstations_info <- st_join(stations, petite_couronne, join = st_within)\n```\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 2\"\nstations_19e <- stations_info %>%\n  filter(grepl(\"19e\", NOM)) %>%\n  st_transform(4326)\narrondissement_19e <- petite_couronne %>%\n  filter(grepl(\"19e\", NOM)) %>%\n  st_transform(4326)\n```\n\n\n<details>\n<summary>\nLa carte obtenue sur la question 2 \n</summary>\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 2, suite\"\npetite_couronne %>% filter(INSEE_DEP == 75) %>%\n  ggplot() +\n    geom_sf(aes(fill = grepl(\"19e\", NOM)), alpha = 0.1) +\n    geom_sf(data = stations_19e, color = \"royalblue\") +\n    scale_fill_viridis_d() +\n    theme_void() +\n    theme(legend.position = \"none\")\n```\n</details>\n\n<details>\n<summary>\nUne version interactive produite avec `leaflet`, que nous d√©couvrirons\nprochainement.\n</summary>\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 2, version interactive\"\npal_fun <- colorQuantile(\"YlOrRd\", NULL, n = 4)\n\nleaflet(stations_19e) %>%\n  addTiles() %>%\n  addCircleMarkers(\n    color = ~pal_fun(capacity),\n    radius = ~sqrt(capacity),\n    popup = ~paste0(name, \": \", capacity, \" places disponibles\"),\n    stroke = FALSE,\n    fillOpacity = 0.5) %>%\n  addPolylines(data = arrondissement_19e)\n```\n</details>\n\n```{r}\n#| output: false\n#| code-fold: true\n#| code-summary: \"Solution question 3\"\n# Question 3\nstations_agg <- stations_info %>%\n  group_by(INSEE_COG) %>%\n  summarise(stationcode_count = n_distinct(stationcode),\n            capacity_sum = sum(capacity)) %>%\n  st_drop_geometry()\n\npetite_couronne <- petite_couronne %>%\n  mutate(area = units::set_units(st_area(.), \"km^2\"))\ndf <- petite_couronne %>% left_join(stations_agg)\n```\n\n<details>\n<summary>\nLa carte obtenue √† la question 3\n</summary>\n\n```{r}\ndf %>% filter(INSEE_DEP == 75) %>%\n  ggplot() +\n    geom_sf(aes(fill = capacity_sum)) +\n    scale_fill_viridis_c() +\n    theme_void() +\n    theme(legend.position = \"bottom\")\n```\n</details>\n\nAvec la carte de la question 3, bas√©e sur des aplats de\ncouleurs (_choropleth map_), le lecteur est victime d'une illusion\nclassique. Les arrondissements les plus visibles sur la carte sont les\nplus grands. D'ailleurs c'est assez logique qu'ils soient √©galement mieux\npourvus en velib. M√™me si l'offre de velib est probablement plus reli√©e\n√† la densit√© de population et d'√©quipements, on peut penser que l'effet\ntaille joue et qu'ainsi on est victime d'une illusion avec la carte pr√©c√©dente.\n\nSi on repr√©sente plut√¥t la capacit√© \nsous forme de densit√©, pour tenir compte\nde la taille diff√©rente des arrondissements,\nles conclusions sont invers√©es et correspondent\nmieux aux attentes d'un mod√®le centr-p√©riph√©rie. Les\narrondissements centraux sont mieux pourvus, cela se voit\nencore mieux avec des ronds proportionnels plut√¥t qu'une\ncarte chorol√®pthe. \n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 4\"\ndf <- df %>% mutate(capacity_density = capacity_sum/as.numeric(area))\n```\n\n```{r}\n#| label: fig-density-velib\n#| fig-cap: \"Densit√© de velib dans l'agglom√©ration parisienne\"\n#| fig-subcap: \n#|   - \"Aplat de couleur\"\n#|   - \"Ronds proportionnels\"\n#| layout-ncol: 2\n#| code-fold: true\n#| code-summary: \"Solution question 4, fin\"\n\ndf %>% filter(INSEE_DEP == 75) %>%\n  ggplot() +\n    geom_sf(aes(fill = capacity_density)) +\n    scale_fill_viridis_c() +\n    theme_void() +\n    theme(legend.position = \"bottom\")\n\nmf_map(x = df %>% filter(INSEE_DEP == 75))\nmf_map(\n  x = df %>% filter(INSEE_DEP == 75),\n  var = \"capacity_density\",\n  type = \"prop\"\n)\n```\n\n## Exercice suppl√©mentaire\n\nLes exercices pr√©c√©dents ont permis de se familiariser au traitement de donn√©es\nspatiales. N√©anmoins il arrive de devoir jongler plus avec la\ndimension g√©om√©trique par exemple pour changer d'√©chelle ou introduire\ndes fusions/dissolutions de g√©om√©tries.\n\nImaginons que chaque utilisateur de velib se d√©place exclusivement\nvers la station la plus proche (√† supposer qu'il n'y a jamais p√©nurie\nou surcapacit√©). Quelle est la carte de la couverture des v√©libs ? \nPour r√©pondre √† ce type de question, on utilise fr√©quemment la\nla [tesselation de Vorono√Ø](https://fr.wikipedia.org/wiki/Diagramme_de_Vorono%C3%AF),\nune op√©ration classique pour transformer des points en polygones. L'exercice suivant\npermet de se familiariser avec cette approche[^notevoronoi].\n\n\n[^notevoronoi]: Dans [ce document de travail](https://www.insee.fr/en/statistiques/4925202) sur donn√©es de t√©l√©phonie mobile, on montre n√©anmoins que cette approche n'est pas sans biais\nsur des ph√©nom√®nes o√π l'hypoth√®se de proximit√© spatiale est\ntrop simplificatrice.\n\n\n::: {.callout-tip}\n## Exercice 5: la tesselation de Vorono√Ø\n\nA l'aide de [cet article](https://www.jla-data.net/eng/spatial-aggregation/), \ncr√©er progressivement votre tesselation de voronoi\n\n1. Construire une enveloppe nomm√©e `petite_couronne_limites` en utilisant\nla fonction `st_union` sur notre fonds de carte des communes de la petite\ncouronne\n2. Cr√©er la tesselation de voronoi en ex√©cutant les √©tapes suivantes:\n    + Ne conserver que les g√©om√©tries avec `st_geometry`\n    + Changer le type d'objet `sf` sous-jacent avec `st_union`\n    + Appliquer la transformation avec `st_voronoi`\n    + Transformer √ßa en objet `sf` auquel on est plus coutumier avec `st_collection_extract(type = \"POLYGON\")` puis `st_sf()`\n    + Appliquer un masque pour couper les parties ext√©rieures √† la petite couronne avec `st_intersection(petite_couronne_limites)`\n    + Joindre √† nouveau aux donn√©es initiales avec `st_join(stations_info)` pour retrouver les attributs pr√©c√©dents\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 1\"\npetite_couronne_limites <- petite_couronne %>% st_union()\n\nvoronoi <- stations_info %>% \n  st_geometry() %>% # to get sfc from sf\n  st_union() %>% # to get a sfc of MULTIPOINT type\n  st_voronoi(envelope = st_geometry(petite_couronne_limites)) %>% # NC sized Voronoi polygon\n  st_collection_extract(type = \"POLYGON\") %>% # a list of polygons\n  st_sf() %>% # from list to sf object\n  st_intersection(petite_couronne_limites) %>% # cut to shape\n  st_join(stations_info) # put names back\n```\n\n3. Du fait de la densit√© des stations dans Paris intramuros, une carte\nau niveau global serait illisible. Il est plus pratique d'avoir une\ncarte _web_ dans laquelle il est possible de naviguer. \nUtiliser le code suivant pour g√©n√©rer cette carte avec `leaflet`: \n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 2\"\n#| echo: true\nvoronoi_velib <- voronoi %>% st_transform(4326) %>%\n  leaflet() %>%\n  addTiles() %>%\n  addPolygons(\n    fillOpacity = 0.1,\n    popup = ~paste0(name, \": \", capacity, \" v√©los disponibles\"),\n    stroke = TRUE, weight = 1)\n```\n\n:::\n\nA vous d'observer la zone de chalandise de la station la plus\nproche de chez vous :\n\n```{r}\nvoronoi_velib\n```\n","srcMarkdownNoYaml":"\n\n::: {.badge}\n<a href=\"https://datalab.sspcloud.fr/launcher/ide/rstudio?version=1.15.13&networking.user.enabled=true&onyxia.friendlyName=%C2%ABrstudio-cours-ENS%C2%BB¬ª&networking.user.enabled=true&onyxia.friendlyName=¬´rstudio-cours-ENS¬ª\" target=\"_blank\" rel=\"noopener\"><img src=\"https://img.shields.io/badge/Tester%20via%20SSP%20cloud%20-%20SSPCloud?logo=R&labelColor=black&color=%231965b8\" alt=\"Onyxia\"></a><br>\n:::\n\n<details>\n<summary>\nD√©rouler les _slides_ ci-dessous ou [cliquer ici](/slides/geospatial.qmd)\npour afficher les slides en plein √©cran.\n</summary>\n\n\n``` {.yaml code-preview=\"/slides/geospatial.qmd\"}\n```\n\n</details>\n\n\nDans ce TP,\nnous allons apprendre √† importer et\nmanipuler des donn√©es spatiales avec\n{{< fa brands r-project >}}.\n\nCe logiciel propose\ndes fonctionnalit√©s tr√®s int√©ressantes pour ce type de\ndonn√©es complexes qui le rendent capable de se comporter\ncomme un SIG. Gr√¢ce √† la librairie [`sf`](https://r-spatial.github.io/sf/), une extension\nde `dplyr` aux donn√©es spatiales, les\ndonn√©es g√©ographiques pourront √™tre manipul√©es\ncomme n'importe quel type de donn√©es avec {{< fa brands r-project >}}.\nLa complexit√© induite par la dimension spatiale ne sera pas ressentie. \n\n\n<details>\n<summary>\n`sf`, une association de tables de donn√©es classiques √† des g√©om√©tries\n</summary>\n![](https://user-images.githubusercontent.com/520851/50280460-e35c1880-044c-11e9-9ed7-cc46754e49db.jpg){width=\"70%\"}\n</details>\n\nSi vous √™tes int√©ress√©s par `Python` {{< fa brands python >}},\nune version tr√®s proche de ce TP est disponible dans [mon cours de l'ENSAE](https://pythonds.linogaliana.fr/content/manipulation/03_geopandas_TP.html).\n\n\n```{r}\n#| eval: false\n#| echo: true\nremotes::install_github(\"linogaliana/cartiflette-r\")\ninstall.packages(\"leaflet\")\n```\n\nDans ce chapitre, nous allons utiliser les packages\nsuivants:\n\n\n```{r}\n#| echo: true\n#| output: false\nlibrary(units)\nlibrary(dplyr)\nlibrary(sf)\nlibrary(ggplot2)\nlibrary(mapsf)\nlibrary(leaflet)\nlibrary(cartiflette)\n```\n\nCe chapitre illustre √† partir d'exemples pratiques certains principes\ncentraux de l'analyse de donn√©es:\n\n- Manipulations sur les attributs des jeux de donn√©es ;\n- Manipulations g√©om√©triques ;\n- Gestion des projections cartographiques ;\n- Cr√©ation rapide de cartes (ce sera approfondi dans un prochain chapitre).\n\n\n::: {.callout-note collapse=\"true\"}\n## Note sur les annotations\n\nCertains exemples de code pr√©sentent des annotations sur le c√¥t√©,\npassez votre souris dessus pour les afficher, comme ci-dessous\n\n```{r}\n#| echo: true\n#| output: false\n\"une annotation explicative m'accompagne √† droite\" #<1>\n```\n1. Je m'affiche quand on passe la souris sur moi üê≠ !\n\n:::\n\n\n## D√©couverte des objets g√©ographiques \n\nDans cette partie,\nnous utiliserons\nles fonds de carte de l'IGN dont\nla mise √† disposition est facilit√©e\npar le projet [`cartiflette`](https://github.com/InseeFrLab/cartiflette.git)[^cartiflette-r].\n\n[^cartiflette-r]:\n  La librairie {{< fa brands r-project >}} est exp√©rimentale mais \n  les prochaines semaines devraient permettre de combler ce manque. \n  Une documentation interactive illustrant le code n√©cessaire pour reproduire\n  telle ou telle carte est disponible sur [linogaliana.github.io/cartiflette-website](https://linogaliana.github.io/cartiflette-website/index.html).\n\n\n::: {.callout-tip}\n## Exercice 1: d√©couverte des objets g√©ographiques\n\nEn premier lieu, on r√©cup√®re des donn√©es g√©ographiques gr√¢ce\nau _package_ `cartiflette`.\n\n1. Utiliser\nle code ci-dessous pour\nt√©l√©charger les donn√©es communales (produit `Admin Express` de l'IGN)\ndes d√©partements de la petite couronne (75, 92, 93 et 94)\nde mani√®re simplifi√©e gr√¢ce au _package_\n`cartiflette`:\n\n```{r}\n#| echo: true\n#| output: false\n#| label: download-borders-communes\n# 1. Chargement des donn√©es de cartiflette\ncommunes_borders <- download_vectorfile_url_all(\n    crs = 4326,\n    values = c(\"75\", \"92\", \"93\", \"94\"),\n    borders=\"COMMUNE\",\n    vectorfile_format=\"geojson\",\n    filter_by=\"DEPARTEMENT\",\n    source=\"EXPRESS-COG-CARTO-TERRITOIRE\",\n    year=2022)\n```\n\n2. Regarder les premi√®res lignes des donn√©es. Identifier la diff√©rence avec\nun _dataframe_ standard. \n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 2\"\n#| output: false\n# 2) Regarder les premi√®res lignes\nhead(communes_borders)\n```\n\n<details>\n<summary>\nPremi√®res lignes des donn√©es\n</summary>\n```{r}\n#| echo: false\n# 2) Regarder les premi√®res lignes\nhead(communes_borders)\n```\n</details>\n\n3. Afficher le `crs` de `communes_borders`. Ce dernier contr√¥le la\ntransformation de l'espace tridimensionnel terrestre en une surface plane.\nUtiliser `st_transform` pour transformer les donn√©es en Lambert 93, le \nsyst√®me officiel (code EPSG 2154). \n\n```{r}\n#| output: false\n#| code-fold: true\n#| code-summary: \"Solution question 3\"\n\n# 3) Afficher le crs\nsf::st_crs(communes_borders)\n# Les donn√©es sont en WGS84, on les reprojette en lambert 93\ncommunes_borders <- communes_borders %>% st_transform(2154)\n```\n\n4. Afficher les communes des Hauts de Seine (d√©partement 92) et repr√©senter rapidement la carte.\n\n```{r}\n#| label: plot-92\n#| output: false\n#| code-fold: true\n#| code-summary: \"Solution question 4\"\n\n# 4) afficher les communes du d√©partement 92\nhds <- communes_borders %>% filter(INSEE_DEP == \"92\")\nmap_92 <- ggplot(hds) +\n    geom_sf(fill = \"white\") + theme_void()\n```\n\n5. Ne conserver que Paris et r√©pr√©senter les fronti√®res sur une carte : quel est le probl√®me pour\nune analyse de Paris intramuros?\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 5\"\nparis_raw <- communes_borders %>% filter(INSEE_DEP == \"75\")\nmap_paris_raw <- ggplot(paris_raw) +\n    geom_sf(fill = \"white\") + theme_void()\n```\n\nOn remarque rapidement le probl√®me. \nOn ne dispose ainsi pas des limites des arrondissements parisiens, ce\nqui appauvrit grandement la carte de Paris. \n\n6. Cette fois, utiliser l'argument `borders=\"COMMUNE_ARRONDISSEMENT\"` pour obtenir\nun fonds de carte consolid√© des communes avec les arrondissements dans les grandes villes. \nConvertir en Lambert 93. \n\n```{r}\n#| output: false\n#| code-fold: true\n#| code-summary: \"Solution question 6\"\n\npetite_couronne <- download_vectorfile_url_all(\n    crs = 4326,\n    values = c(\"75\", \"92\", \"93\", \"94\"),\n    borders=\"COMMUNE_ARRONDISSEMENT\",\n    vectorfile_format=\"geojson\",\n    filter_by=\"DEPARTEMENT\",\n    source=\"EXPRESS-COG-CARTO-TERRITOIRE\",\n    year=2022) %>%\n  st_transform(2154)\npetite_couronne_mercator <- petite_couronne %>%\n  st_transform(4326)\n\nmap_paris_arrondissements <- ggplot(petite_couronne) +\n    geom_sf(fill = \"white\") + theme_void()\n```\n\n\n:::\n\n\n<details>\n\n<summary>\nSi vous d√©sirez observer l'aspect de la\ncarte du 92 (question 4), d√©roulez cette partie.\n</summary>\n\n```{r}\n#| echo: false\nmap_92\n```\n\n</details>\n\n<details>\n<summary>\nCarte de Paris attendue √† la question 5 et √† la question 6\n</summary>\n\nA la question 5, Paris intra-muros est bien pauvre: \n\n```{r}\n#| echo: false\n# 5) Repr√©senter la carte de Paris. Quel est le probl√®me ?\nmap_paris_raw\n```\n\nA l'issue de la  question 6, on a bien une carte de la petite couronne avec\ndes arrondissements:\n\n```{r}\n#| echo: false\n# 6) Repr√©senter la carte de Paris avec arrondissements\nmap_paris_arrondissements\n```\n\n\n</details>\n\n## Le syst√®me de projection\n\nUn concept central dans les logiciels de SIG est la notion de \n__projection__. L'exercice pr√©c√©dent imposait parfois certaines projections\nsans expliquer l'importance de ces choix. {{< fa brands r-project >}}, comme\ntout SIG, permet une gestion coh√©rente des projections. \n\nL'exercice suivant vise √† introduire aux principales\nfonctionnalit√©s de {{< fa brands r-project >}}\n√† ce propos. Il illustre les probl√®mes communs que peuvent rencontrer\nles g√©ographes dans la gestion des syst√®mes de projection. \n\nObservez les variations significatives\nde proportions pour certains pays selon les projections\nchoisies:\n\n```{ojs}\n//| echo: false\nhtml`<div>${container_projection}</div>`\n``` \n\n{{< include \"../utils/play_projection_d3.qmd\" >}}\n\n```{ojs}\n//| echo: false\nwidth_projected_map = screen.width/2\n```\n\n\n\n::: {.callout-tip}\n## Exercice 2: Les projections, repr√©sentations et approximations\n\nVoici un code utilisant encore\n`cartiflette` \npour r√©cup√©rer les fronti√®res fran√ßaises (d√©coup√©es par r√©gion):\n\n```{r}\n#| output: false\n#| echo: true\nfrance <- download_vectorfile_url_all(\n      values = \"metropole\",\n      crs = 4326,\n      borders = \"REGION\",\n      vectorfile_format=\"geojson\",\n      filter_by=\"FRANCE_ENTIERE\",\n      source=\"EXPRESS-COG-CARTO-TERRITOIRE\",\n      year=2022)\n```\n\n```{r}\n# eval: true\nst_crs(france) <- 4326\nst_crs(france$geometry) <- 4326\n```\n\n1. S'amuser √† repr√©senter les limites de la France avec plusieurs projections:\n\n- Mercator WGS84 (EPSG: 4326)\n- Projection healpix (`+proj=healpix +lon_0=0 +a=1`)\n- Projection pr√©vue pour Tahiti (EPSG: 3304)\n- Projection Albers pr√©vue pour Etats-Unis (EPSG: 5070)\n\n2. Utiliser la fonction `st_area` sur calculer la superficie en $km^2$\ndes r√©gions fran√ßaises dans les deux syst√®mes de projection suivants: \nWGS84 (EPSG: 4326) et Lambert 93 (EPSG: 2154). Calculer la diff√©rence en $km^2$\npour chaque r√©gion.\n:::\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 1\"\n#| eval: false\n#| output: false\nfrance_2154 <- france %>% sf::st_transform(2154)\nfrance_healpix <- france %>% sf::st_transform(\"+proj=healpix +lon_0=0 +a=1\")\nfrance_5070 <- france %>% sf::st_transform(5070)\nfrance_3304 <- france %>% sf::st_transform(3304)\n```\n\nAvec la question 1 illustrant quelques cas pathologiques,\non comprend que les projections ont un effet d√©formant\nqui se voit bien lorsqu'on les repr√©sente c√¥te √† c√¥te sous\nforme de cartes :\n\n```{r}\n#| eval: false\n#| label: fig-effet-mercator\n#| fig-cap: \"Comparaison des projections\"\n#| fig-subcap: \n#|   - \"Mercator WGS84 (EPSG: 4326)\"\n#|   - \"Projection healpix (+proj=healpix +lon_0=0 +a=1)\"\n#|   - \"Projection pr√©vue pour Tahiti (EPSG: 3304)\"\n#|   - \"Projection Albers pr√©vue pour Etats-Unis (EPSG: 5070)\"\n#| layout-ncol: 2\n\nggplot(france) +\n    geom_sf(fill = \"white\") + theme_void()\n\nggplot(france_healpix) +\n    geom_sf(fill = \"white\") + theme_void()\n\nggplot(france_3304) +\n    geom_sf(fill = \"white\") + theme_void()\n\nggplot(france_5070) +\n    geom_sf(fill = \"white\") + theme_void()\n```\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 2\"\n\nmismatch_france <- france %>%\n  mutate(superficie_4326 = set_units(st_area(.), \"km^2\")) %>%\n  st_transform(2154) %>%\n  mutate(superficie_2154 = set_units(st_area(.), \"km^2\")) %>%\n  mutate(mismatch = superficie_2154-superficie_4326) %>%\n  select(NOM, superficie_4326, superficie_2154, mismatch)\n```\n\nCependant le probl√®me n'est pas que visuel, il est √©galement\nnum√©rique. Les calculs g√©om√©triques am√®nent √† des diff√©rences\nassez notables selon le syst√®me de r√©f√©rence utilis√©.\n\n<details>\n<summary>\nVoir le tableau des approximations pour chaque r√©gion\n</summary>\n```{r}\nmismatch_france %>% arrange(desc(mismatch))\n```\n</details>\n\nOn peut repr√©senter ces approximations sur une carte[^notecarte] pour se faire\nune id√©e des r√©gions o√π l'erreur de mesure est la plus importante.\n\n[^notecarte]: Cette carte n'est pas trop soign√©e,\nc'est normal nous verrons comment\nfaire de belles cartes ult√©rieurement.\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 2, suite\"\n\n#| label: fig-erreur-mesure\n#| fig-cap: Approximations li√©es au syst√®me de projection WGS 84\nggplot(mismatch_france) +\n  geom_sf(aes(fill = as.numeric(mismatch))) +\n  scale_fill_gradient2() +\n  labs(title = \"Approximations li√©es √† la projection\", fill = \"km¬≤\") +\n  theme_void() + theme(legend.position = \"bottom\")\n```\n\nCe type d'erreur de mesure est normal √† l'√©chelle du territoire fran√ßais. \nLes projections h√©rit√®res du Mercator d√©forment les distances,\nsurtout lorqu'on se rapproche de l'√©quateur ou des p√¥les. \n\n::: {#fig-mercator}\n\n![Exemple de reprojection de pays depuis le site [thetruesize.com](https://www.thetruesize.com/)](https://pythonds.linogaliana.fr/content/manipulation/truesize.png){#fig-surus}\n\n![\"Don't trust the Mercator projection\" sur `Reddit`](img/mercator.jpg){#fig-mercator-funny}\n\nLa projection Mercator, une vision d√©formante\n:::\n\nPour aller plus loin, la carte interactive\nsuivante, construite par Nicolas Lambert, issue de\nce [_notebook_ `Observable`](https://observablehq.com/@neocartocnrs/impact-of-projections-on-areas), illustre l'effet\nd√©formant de la projection Mercator, et de quelques unes autres,\nsur notre perception de la taille des pays.\n\n<details>\n<summary>\nVoir la carte interactive\n</summary>\n```{ojs}\nhtml`<div class=\"grid-container\">\n  <div class=\"viewof-projection\">${viewof projectionBertin}</div>\n  <div class=\"viewof-mycountry\">${viewof mycountry}</div>\n  <div class=\"map-bertin\">${mapBertin}</div>\n</div>`\n```\n\n</details>\n\n```{ojs}\nimport {map as mapBertin, viewof projection as projectionBertin, viewof mycountry} from \"@neocartocnrs/impact-of-projections-on-areas\"\n```\n\n\n\nIl n'est donc pas suprenant que nos d√©formations soient exacerb√©es aux\nextr√®mes du territoire m√©tropolitain. \nSi les approximations sont l√©g√®res sur de petits territoires,\nles erreurs peuvent √™tre \nnon n√©gligeables √† l'√©chelle de la France.\n\nIl faut donc syst√©matiquement\nrepasser les donn√©es dans le syst√®me de projection Lambert 93 (le\nsyst√®me officiel pour la m√©tropole) avant d'effectuer des calculs g√©om√©triques.\n\n\n\n## Utiliser des donn√©es g√©ographiques comme des couches graphiques\n\n\nSouvent, le d√©coupage communal ne sert qu'en fond de cartes, pour donner des\nrep√®res. En compl√©ment de celui-ci, on peut d√©sirer exploiter\nun autre jeu de donn√©es.\n\nOn va partir des donn√©es de localisation des\nstations velib, \ndisponibles [sur le site d'open data de la ville de Paris](https://opendata.paris.fr/explore/dataset/velib-emplacement-des-stations/table/) et \nrequ√™tables directement en utilisant un URL\n\n\n```{r}\n#| echo: true\nurl <- \"https://opendata.paris.fr/explore/dataset/velib-emplacement-des-stations/download/?format=geojson&timezone=Europe/Berlin&lang=fr\"\n```\n\n\nDans le prochain exercice, nous proposons de cr√©er rapidement une \ncarte comprenant trois couches:\n\n- Les localisations de stations sous forme de points ;\n- Les bordures des communes et arrondissements pour contextualiser ;\n- Les bordures des d√©partements en traits plus larges pour contextualiser √©galement. \n\nNous irons plus loin dans le travail cartographique dans le prochain\nchapitre. Mais √™tre en mesure de positionner rapidement\nses donn√©es sur une carte est\ntoujours utile dans un travail exploratoire. \n\nEn amont de l'exercice,\nutiliser la fonction suivante du _package_ `cartiflette` pour r√©cup√©rer\nle fonds de carte des d√©partements de la petite couronne:\n\n```{r}\n#| echo: true\n#| output: false\nidf <- download_vectorfile_url_all(\n      values = \"11\",\n      crs = 4326,\n      borders = \"DEPARTEMENT\",\n      vectorfile_format=\"geojson\",\n      filter_by=\"REGION\",\n      source=\"EXPRESS-COG-CARTO-TERRITOIRE\",\n      year=2022)\npetite_couronne_departements <- idf %>%\n  filter(INSEE_DEP %in% c(\"75\",\"92\",\"93\",\"94\"))\n```\n\n\n\n::: {.callout-tip}\n## Exercice 3: importer et explorer les donn√©es velib\n\nOn commence par r√©cup√©rer les donn√©es n√©cessaires √† la production\nde cette carte.\n\n1. En utilisant l'URL pr√©c√©dent, importer les donn√©es velib sous le nom `station`\n2. V√©rifier la projection g√©ographique de `station` (attribut `crs`). Si celle-ci est diff√©rente des donn√©es communales, reprojeter ces\nderni√®res dans le m√™me syst√®me de projection que les stations de v√©lib\n3. Ne conserver que les 50 principales stations (variable `capacity`)\n\nOn peut maintenant construire la carte de mani√®re s√©quentielle avec `ggplot`\n\n4. En premier lieu, gr√¢ce √† `geom_sf`, \nrepr√©senter exclusivement les positions des stations\net ajuster la taille en fonction de la variable `capacity`\n\n5. Ajouter la couche des communes d'arrondissements et des communes\n    + Comme ces limites administratives sont stock√©es dans un _dataframe_ diff√©rent, il va falloir utiliser l'argument `data`\n    + Utiliser `fill = \"transparent\"` pour que l'int√©rieur du polygone ne masque pas nos points\n\n6. Ajouter la couche des d√©partements\n\n7. En supposant que votre objet `ggplot` s'appelle `carte`, vous pouvez\nutiliser le code suivant pour am√©liorer rapidement l'esth√©tique\n\n```r\ncarte +\n  theme_void() +\n  theme(legend.position = \"bottom\") +\n  guides(color = \"none\", size = guide_legend(title.position=\"top\", title.hjust = 0.5)) +\n  labs(size = \"Capacit√© de la station\", title = \"Les 50 principales stations de v√©lib\")\n```\n\n\n:::\n\n```{r}\n#| output: false\n#| code-fold: true\n#| code-summary: \"Solution question 1\"\n# 1. Importer les donn√©es velib\nstations <- st_read(url)\n```\n\n```{r}\n#| output: false\n#| code-fold: true\n#| code-summary: \"Solution question 2\"\n# 2. Reprojection\nst_crs(stations)\nstations <- stations %>% \n  st_transform(st_crs(petite_couronne))\n```\n\n\n```{r}\n#| output: false\n#| code-fold: true\n#| code-summary: \"Solution question 3\"\n# 3. Principales stations\nprincipales_stations <- stations %>%\n  arrange(desc(capacity)) %>%\n  head(50)\n```\n\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 4\"\n# 4. Principales stations sous forme de nuage de points\ncarte <- ggplot(principales_stations) +\n  geom_sf(aes(color = \"red\", size = capacity))\n```\n\n<details>\n<summary>\nLes stations plac√©es sur un plan, √† l'issue de la question 4\n</summary>\n```{r}\ncarte\n```\n</details>\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 5\"\n# Question 5\ncarte <- carte + geom_sf(data = petite_couronne, fill = \"transparent\")\n```\n\n<details>\n<summary>\nAjout d'une couche d'arrondissements (question 5)\n</summary>\n\n```{r}\ncarte\n```\n</details>\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 6\"\n# Question 6\ncarte <- carte +\n  geom_sf(data = petite_couronne_departements, fill = \"transparent\", color = \"blue\")\n```\n\n<details>\n<summary>\nAjout de la couche des d√©partements (question 6)\n</summary>\n\n```{r}\ncarte\n```\n\n</details>\n\nLa carte finalis√©e (question 7), obtenue gr√¢ce √† une demi-douzaine de lignes\nde code seulement, est ainsi:\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 7\"\n# Question 7\ncarte +\n  theme_void() +\n  theme(legend.position = \"bottom\") +\n  guides(color = \"none\", size = guide_legend(title.position=\"top\", title.hjust = 0.5)) +\n  labs(size = \"Capacit√© de la station\", title = \"Les 50 principales stations de v√©lib\")\n```\n\n\n\n\n## Jointures spatiales\n\nLes jointures attributaires fonctionnent comme avec un `tibble` classique.\nPour conserver un objet spatial *in fine*, il faut faire attention √† utiliser en premier (base de gauche) l'objet `sf`.\nEn revanche, l'un des int√©r√™ts des objets `sf` est qu'on peut √©galement faire une jointure sur la dimension spatiale gr√¢ce √† plusieurs fonctions. Les jointures les plus communes sont:\n\n| Fonction |\tOp√©ration |\n|----------|------------|\n|`st_intersects()` | \tQuelles g√©om√©tries de x intersectent celles de y ? |\n|`st_contains()` | \tQuelles g√©om√©tries de x contiennent celles de y ? |\n|`st_disjoint()` | \tQuelles g√©om√©tries de x sont disjointes √† celles de y ? |\n|`st_is_within_distance()` | \tQuelles g√©om√©tries de x est √† moins de m/km de celles de y ? |\n\nLa documentation √† laquelle se\nr√©f√©rer est [ici](https://cran.r-project.org/web/packages/sfnetworks/vignettes/sfn03_join_filter.html). \nUne version p√©dagogique se trouve dans la documentation [`utilitR`](https://www.book.utilitr.org/03_fiches_thematiques/fiche_donnees_spatiales#joindre-des-donn%C3%A9es-g%C3%A9ographiques-et-attributaires). \n\n\n::: {.callout-tip}\n## Exercice 4: Associer les stations aux communes et arrondissements auxquels elles appartiennent\n\nDans cet exercice, on va supposer que :\n\n- les localisations des stations `velib` \nsont stock√©es dans un _dataframe_ nomm√© `stations`\n- les donn√©es administratives\nsont dans un _dataframe_ nomm√© `petite_couronne`.\n\n1. Faire une jointure spatiale pour enrichir les donn√©es de stations en y ajoutant des informations de `petite_couronne`. Appeler cet objet `stations_info`\n2. Cr√©er les objets `stations_19e` et `arrondissement_19e` pour stocker, respectivement, \nles stations appartenant au 19e et les limites de l'arrondissement\n2. Repr√©senter la carte des stations du 19e arrondissement avec le code suivant:\n\n```r\npetite_couronne %>% filter(INSEE_DEP == 75) %>%\n  ggplot() +\n    geom_sf(aes(fill = grepl(\"19e\", NOM)), alpha = 0.1) +\n    geom_sf(data = stations_19e, color = \"royalblue\") +\n    scale_fill_viridis_d() +\n    theme_void() +\n    theme(legend.position = \"none\")\n```\n\n3. Compter le nombre de stations velib et le nombre de places velib par arrondissement ou commune. Repr√©senter sur une carte chacune des informations\n4. Repr√©senter les m√™mes informations mais en densit√© (diviser par la surface de l'arrondissement ou commune en km2)\n5. (optionnel) Choisir une des cartes de densit√© et la nettoyer (retirer les axes, mettre les titres...)\n\n:::\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 1\"\nstations_info <- st_join(stations, petite_couronne, join = st_within)\n```\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 2\"\nstations_19e <- stations_info %>%\n  filter(grepl(\"19e\", NOM)) %>%\n  st_transform(4326)\narrondissement_19e <- petite_couronne %>%\n  filter(grepl(\"19e\", NOM)) %>%\n  st_transform(4326)\n```\n\n\n<details>\n<summary>\nLa carte obtenue sur la question 2 \n</summary>\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 2, suite\"\npetite_couronne %>% filter(INSEE_DEP == 75) %>%\n  ggplot() +\n    geom_sf(aes(fill = grepl(\"19e\", NOM)), alpha = 0.1) +\n    geom_sf(data = stations_19e, color = \"royalblue\") +\n    scale_fill_viridis_d() +\n    theme_void() +\n    theme(legend.position = \"none\")\n```\n</details>\n\n<details>\n<summary>\nUne version interactive produite avec `leaflet`, que nous d√©couvrirons\nprochainement.\n</summary>\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 2, version interactive\"\npal_fun <- colorQuantile(\"YlOrRd\", NULL, n = 4)\n\nleaflet(stations_19e) %>%\n  addTiles() %>%\n  addCircleMarkers(\n    color = ~pal_fun(capacity),\n    radius = ~sqrt(capacity),\n    popup = ~paste0(name, \": \", capacity, \" places disponibles\"),\n    stroke = FALSE,\n    fillOpacity = 0.5) %>%\n  addPolylines(data = arrondissement_19e)\n```\n</details>\n\n```{r}\n#| output: false\n#| code-fold: true\n#| code-summary: \"Solution question 3\"\n# Question 3\nstations_agg <- stations_info %>%\n  group_by(INSEE_COG) %>%\n  summarise(stationcode_count = n_distinct(stationcode),\n            capacity_sum = sum(capacity)) %>%\n  st_drop_geometry()\n\npetite_couronne <- petite_couronne %>%\n  mutate(area = units::set_units(st_area(.), \"km^2\"))\ndf <- petite_couronne %>% left_join(stations_agg)\n```\n\n<details>\n<summary>\nLa carte obtenue √† la question 3\n</summary>\n\n```{r}\ndf %>% filter(INSEE_DEP == 75) %>%\n  ggplot() +\n    geom_sf(aes(fill = capacity_sum)) +\n    scale_fill_viridis_c() +\n    theme_void() +\n    theme(legend.position = \"bottom\")\n```\n</details>\n\nAvec la carte de la question 3, bas√©e sur des aplats de\ncouleurs (_choropleth map_), le lecteur est victime d'une illusion\nclassique. Les arrondissements les plus visibles sur la carte sont les\nplus grands. D'ailleurs c'est assez logique qu'ils soient √©galement mieux\npourvus en velib. M√™me si l'offre de velib est probablement plus reli√©e\n√† la densit√© de population et d'√©quipements, on peut penser que l'effet\ntaille joue et qu'ainsi on est victime d'une illusion avec la carte pr√©c√©dente.\n\nSi on repr√©sente plut√¥t la capacit√© \nsous forme de densit√©, pour tenir compte\nde la taille diff√©rente des arrondissements,\nles conclusions sont invers√©es et correspondent\nmieux aux attentes d'un mod√®le centr-p√©riph√©rie. Les\narrondissements centraux sont mieux pourvus, cela se voit\nencore mieux avec des ronds proportionnels plut√¥t qu'une\ncarte chorol√®pthe. \n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 4\"\ndf <- df %>% mutate(capacity_density = capacity_sum/as.numeric(area))\n```\n\n```{r}\n#| label: fig-density-velib\n#| fig-cap: \"Densit√© de velib dans l'agglom√©ration parisienne\"\n#| fig-subcap: \n#|   - \"Aplat de couleur\"\n#|   - \"Ronds proportionnels\"\n#| layout-ncol: 2\n#| code-fold: true\n#| code-summary: \"Solution question 4, fin\"\n\ndf %>% filter(INSEE_DEP == 75) %>%\n  ggplot() +\n    geom_sf(aes(fill = capacity_density)) +\n    scale_fill_viridis_c() +\n    theme_void() +\n    theme(legend.position = \"bottom\")\n\nmf_map(x = df %>% filter(INSEE_DEP == 75))\nmf_map(\n  x = df %>% filter(INSEE_DEP == 75),\n  var = \"capacity_density\",\n  type = \"prop\"\n)\n```\n\n## Exercice suppl√©mentaire\n\nLes exercices pr√©c√©dents ont permis de se familiariser au traitement de donn√©es\nspatiales. N√©anmoins il arrive de devoir jongler plus avec la\ndimension g√©om√©trique par exemple pour changer d'√©chelle ou introduire\ndes fusions/dissolutions de g√©om√©tries.\n\nImaginons que chaque utilisateur de velib se d√©place exclusivement\nvers la station la plus proche (√† supposer qu'il n'y a jamais p√©nurie\nou surcapacit√©). Quelle est la carte de la couverture des v√©libs ? \nPour r√©pondre √† ce type de question, on utilise fr√©quemment la\nla [tesselation de Vorono√Ø](https://fr.wikipedia.org/wiki/Diagramme_de_Vorono%C3%AF),\nune op√©ration classique pour transformer des points en polygones. L'exercice suivant\npermet de se familiariser avec cette approche[^notevoronoi].\n\n\n[^notevoronoi]: Dans [ce document de travail](https://www.insee.fr/en/statistiques/4925202) sur donn√©es de t√©l√©phonie mobile, on montre n√©anmoins que cette approche n'est pas sans biais\nsur des ph√©nom√®nes o√π l'hypoth√®se de proximit√© spatiale est\ntrop simplificatrice.\n\n\n::: {.callout-tip}\n## Exercice 5: la tesselation de Vorono√Ø\n\nA l'aide de [cet article](https://www.jla-data.net/eng/spatial-aggregation/), \ncr√©er progressivement votre tesselation de voronoi\n\n1. Construire une enveloppe nomm√©e `petite_couronne_limites` en utilisant\nla fonction `st_union` sur notre fonds de carte des communes de la petite\ncouronne\n2. Cr√©er la tesselation de voronoi en ex√©cutant les √©tapes suivantes:\n    + Ne conserver que les g√©om√©tries avec `st_geometry`\n    + Changer le type d'objet `sf` sous-jacent avec `st_union`\n    + Appliquer la transformation avec `st_voronoi`\n    + Transformer √ßa en objet `sf` auquel on est plus coutumier avec `st_collection_extract(type = \"POLYGON\")` puis `st_sf()`\n    + Appliquer un masque pour couper les parties ext√©rieures √† la petite couronne avec `st_intersection(petite_couronne_limites)`\n    + Joindre √† nouveau aux donn√©es initiales avec `st_join(stations_info)` pour retrouver les attributs pr√©c√©dents\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 1\"\npetite_couronne_limites <- petite_couronne %>% st_union()\n\nvoronoi <- stations_info %>% \n  st_geometry() %>% # to get sfc from sf\n  st_union() %>% # to get a sfc of MULTIPOINT type\n  st_voronoi(envelope = st_geometry(petite_couronne_limites)) %>% # NC sized Voronoi polygon\n  st_collection_extract(type = \"POLYGON\") %>% # a list of polygons\n  st_sf() %>% # from list to sf object\n  st_intersection(petite_couronne_limites) %>% # cut to shape\n  st_join(stations_info) # put names back\n```\n\n3. Du fait de la densit√© des stations dans Paris intramuros, une carte\nau niveau global serait illisible. Il est plus pratique d'avoir une\ncarte _web_ dans laquelle il est possible de naviguer. \nUtiliser le code suivant pour g√©n√©rer cette carte avec `leaflet`: \n\n```{r}\n#| code-fold: true\n#| code-summary: \"Solution question 2\"\n#| echo: true\nvoronoi_velib <- voronoi %>% st_transform(4326) %>%\n  leaflet() %>%\n  addTiles() %>%\n  addPolygons(\n    fillOpacity = 0.1,\n    popup = ~paste0(name, \": \", capacity, \" v√©los disponibles\"),\n    stroke = TRUE, weight = 1)\n```\n\n:::\n\nA vous d'observer la zone de chalandise de la station la plus\nproche de chez vous :\n\n```{r}\nvoronoi_velib\n```\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":true,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../styles.css"],"toc":true,"number-sections":true,"output-file":"geospatial-wrangling.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.8.27","author":"Lino Galiana","theme":"cosmo","code-annotations":"hover","title":"Manipuler des donn√©es spatiales avec `sf`"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}